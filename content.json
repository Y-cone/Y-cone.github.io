{"meta":{"title":"Y博客","subtitle":"","description":"记录自己学习笔记的博客","author":"yc","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-05-02T17:57:53.771Z","updated":"2023-05-02T17:57:53.771Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-05-02T17:48:56.287Z","updated":"2023-05-02T17:48:56.287Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"暂时没想好"},{"title":"所有标签","date":"2023-05-02T17:49:22.543Z","updated":"2023-05-02T17:49:22.543Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-05-02T17:48:34.122Z","updated":"2023-05-02T17:48:34.122Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-05-02T17:50:46.107Z","updated":"2023-05-02T17:50:46.107Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"mysql 锁","slug":"mysql-锁","date":"2023-05-09T13:39:09.000Z","updated":"2023-05-13T10:04:47.971Z","comments":true,"path":"3095cec1.html","link":"","permalink":"http://example.com/3095cec1.html","excerpt":"","text":"锁概述 介绍 锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。 分类 MySQL中的锁，按照锁的粒度分，分为以下三类： 全局锁：锁定数据库中的所有表。 表级锁：每次操作锁住整张表。 行级锁：每次操作锁住对应的行数据。 全局锁 介绍 全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，以及更新操作的事务提交语句都将被阻塞。 其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。 演示 语法 加锁：flush tables with read lock; 备份：mysqldump -u用户名 -p密码 数据库名称 &gt; 备份文件的路径，==注意mysqldump是MySQL提供的一个工具，不是SQL语句，所以不要在MySQL的命令行运行，直接在系统的命令行运行。== 释放锁：unlock tables; 特点 数据库中加全局锁，是一个比较重的操作，存在以下问题： 如果在主库上备份 ，那么在备份期间都不能执行更新，业务基本上就得停摆。 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制文件（binlog），会导致主从延迟。 在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份。 mysqldump --single-transaction -uxxx -pxxx 数据库名 &gt; 备份文件路径 表级锁 介绍 表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。 对于表级锁，主要分为以下三类： 表锁 元数据锁（meta data lock，MDL） 意向锁 表锁 对于表锁，分为两类： 表共享读锁（read lock） 表独占写锁（write lock） 语法： 加锁：lock tables 表名... read/write 释放锁：unlock tables / 客户端断开连接 ==读锁不会阻塞其他客户端的读，但是会阻塞写。写锁即会阻塞其他客户端的读，又会阻塞其他客户端的写。== 元数据锁（meta data lock，MDL） MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性（这里元数据可以理解为表结构），在表上有活动事务的时候，不可以对元数据进行写入操作。==为了避免DML与DDL冲突，保证读写的正确性。== 在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）。 对应SQL 元数据锁类型 说明 lock tables xxx read/write SHARED_READ_ONLY / SHARED_NO_READ_WRITE select、select...lock in share mode SHARED_READ 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 insert、update、delete、select ... for update SHARED_WRITE 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 alter table ... EXCLUSIVE 与其他的MDL都互斥 查看元数据锁： select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks; 意向锁 为了避免DML在执行时，加的行锁与表锁的冲突就，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。 意向共享锁（IS）：由语句select … lock in share mode 添加。与表锁共享锁（read）兼容，与表锁排他锁（write）互斥。 意向排他锁（IX）：由insert、update、delete、select … for update 添加。与表锁共享锁（read）及排他锁（write）都互斥。==意向锁之间不会互斥。== 可以通过以下SQL语句，查看意向锁及行锁的加锁情况： select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks; 弹幕笔记摘要： 明显写锁和谁都冲突，读锁和任何读锁都兼容，很好理解因为都只读； 总的来说，意向锁并不是真正意义上的锁，只是一个记载锁的数据结构，可以这么理解，不要被它的名字骗了； 要说意向锁是锁的话，那么它算是表级锁； 锁是一种资源，是要被争抢的，被事务获取； 产生意向锁时也会产生元数据锁； 原来懵的不止我一个(-_-)； 意向锁解决的是行锁和表锁的冲突问题； 行级锁 介绍 行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。 InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类： 行锁（Record Lock）：锁定单个记录的锁，防止其他事务对此进行update和delete。在RC、RR隔离级别下都支持。 间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。 临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。 行锁 InnoDB实现了以下两种类型的行锁： 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁； 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁； SQL 行锁类型 说明 INSERT … 排他锁 自动加锁 UPDATE … 排他锁 自动加锁 DELETE … 排他锁 自动加锁 SELECT(正常) 不加任何锁 SELECT … LOCK IN SHARE MODE 共享锁 需要手动在SELECT之后加LOCK IN SHARE MODE SELECT … FOR UPDATE 排他锁 需要手动在SELECT之后加 FOR UPDATE 默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。 InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁。 可以通过以下SQL，查看意向锁及行锁的加锁情况： select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks; 弹幕摘要：记住这里，select一定要自己主动去加锁，如果不主动加锁是可以发生幻读的； 间隙锁/临键锁 默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。 索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。 索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。 索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止。 ==注意 ：间隙锁的唯一目的就是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一个间隙上采用间隙锁。==","categories":[{"name":"mysql学习","slug":"mysql学习","permalink":"http://example.com/categories/mysql%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"mysql-触发器","slug":"mysql-触发器","date":"2023-05-09T13:37:31.000Z","updated":"2023-05-13T09:43:11.302Z","comments":true,"path":"d71f2100.html","link":"","permalink":"http://example.com/d71f2100.html","excerpt":"","text":"触发器介绍触发器是与表有关的数据库对象，指在insert/update/delete之前或之后，触发并执行触发器中定义SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。 使用别 名OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD INSERT型触发器 NEW 表示将要或者已经新增的数据类型 UPDATE型触发器 OLD 表示修改之前的数据，NEW 表示将要修改或者已经修改后的数据 DELETE型触发器 OLD 表示将要或者已经删除的数据 语法 创建 123456CREATE TRIGGER trigger_nameBEFORE/AFTER INSERT/UPDATE/DELETEON tbl_name FOR EACH ROW -- 行级触发器BEGIN trigger_stmt;END; 查看 1SHOW TRIGGERS; 删除 1DROP TRIGGER [schema_name.]trigger_name; -- 如果没有指定schema_name，默认为当前数据库。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263-- 触发器-- 准备工作：日志表 user_logsCREATE TABLE user_logs( id INT(11) NOT NULL auto_increment, operation VARCHAR(20) NOT NULL COMMENT &#x27;操作类型，insert/update/delete&#x27;, operate_time datetime NOT NULL COMMENT &#x27;操作时间&#x27;, operate_empno INT(11) NOT NULL COMMENT &#x27;操作的empno&#x27;, operate_params VARCHAR(1000) COMMENT &#x27;操作参数&#x27;, PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8;-- 插入数据触发器(insert)CREATE TRIGGER emp_insert_trigger AFTER INSERT ON emp FOR EACH ROWBEGIN INSERT INTO user_logs VALUES(null, &#x27;insert&#x27;, NOW(), new.empno, CONCAT(&#x27;输入的内容：&#x27;,new.empno,new.ename, new.job, new.mgr,new.hiredate,new.sal,new.comm,new.deptno));END; -- 查看 SHOW TRIGGERS;-- 删除DROP TRIGGER emp_insert_trigger;INSERT INTO emp VALUES(7800, &#x27;TIM&#x27;, &#x27;SALESMAN&#x27;,7902, &#x27;1980-12-15 00:00:00&#x27;, 900, 1000, 20);SELECT * FROM user_logs;-- 修改数据触发器(update)CREATE TRIGGER emp_update_trigger AFTER UPDATE ON emp FOR EACH ROWBEGIN INSERT INTO user_logs VALUES(null, &#x27;update&#x27;, NOW(), new.empno, CONCAT(&#x27;更新之前的数据：&#x27;,&#x27;empno=&#x27;,old.empno,&#x27;ename=&#x27;,old.ename,&#x27;job=&#x27;, old.job, &#x27;mgr=&#x27;,old.mgr,&#x27;hiredate=&#x27;,old.hiredate,&#x27;sal=&#x27;,old.sal,&#x27;comm=&#x27;,old.comm,&#x27;deptno=&#x27;,old.deptno,&#x27;| 更新之后的数据：&#x27;,&#x27;empno=&#x27;,new.empno,&#x27;ename=&#x27;,new.ename,&#x27;job=&#x27;, new.job, &#x27;mgr=&#x27;,new.mgr,&#x27;hiredate=&#x27;,new.hiredate,&#x27;sal=&#x27;,new.sal,&#x27;comm=&#x27;,new.comm,&#x27;deptno=&#x27;,new.deptno));END;SHOW TRIGGERS;UPDATE emp SET sal = 1900 WHERE empno = 7800;UPDATE emp SET sal = 1900 WHERE empno &lt; 7800; -- empno &lt; 7800 的记录有几条，就执行几次触发器SELECT * FROM user_logs;-- 删除数据的触发器（delete）CREATE TRIGGER emp_delete_trigger AFTER DELETE ON emp FOR EACH ROWBEGIN INSERT INTO user_logs VALUES(null, &#x27;delete&#x27;, NOW(), old.empno, CONCAT(&#x27;删除之前的数据：&#x27;,&#x27;empno=&#x27;,old.empno,&#x27;ename=&#x27;,old.ename,&#x27;job=&#x27;, old.job, &#x27;mgr=&#x27;,old.mgr,&#x27;hiredate=&#x27;,old.hiredate,&#x27;sal=&#x27;,old.sal,&#x27;comm=&#x27;,old.comm,&#x27;deptno=&#x27;,old.deptno));END;SHOW TRIGGERS;DELETE FROM emp WHERE empno = 7800;SELECT * FROM user_logs;","categories":[{"name":"mysql学习","slug":"mysql学习","permalink":"http://example.com/categories/mysql%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"p11 Properties","slug":"p11-Properties","date":"2023-05-08T13:37:21.000Z","updated":"2023-05-13T09:43:11.308Z","comments":true,"path":"c33f51f5.html","link":"","permalink":"http://example.com/c33f51f5.html","excerpt":"","text":"# Properties类 基本介绍 专门用于读写配置文件的集合类 配置文件的格式： 键=值 键=值 注意：键值对不需要有空格，值不需要用引号一起来。默认类型是String。 Properties的常见方法 load：加载配置文件的键值对 到Properties对象； list：将数据显示到指定设备/流对象； getProperty(key)：根据键获取值； setProperty(key, value)：设置键值对到Properties对象； store：将Properties中的键值对存储到配置文件，在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码； 读文件 示例文件：mysql.properties 123ip=192.168.100.100user=rootpwd=12345 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.util.Properties;/** * @author: 86199 * @date: 2023/5/8 20:06 * @description: */public class Properties02 &#123; public static void main(String[] args) throws IOException &#123; //使用Properties类 来读取mysql.properties 文件 //1. 创建Properties对象 Properties properties = new Properties(); //2. 加载指定配置文件 properties.load(new FileReader(&quot;src\\\\mysql.properties&quot;)); //3. 把 k-v 显示到控制台 properties.list(System.out); //4. 根据key获取对应的值 String user = properties.getProperty(&quot;user&quot;); String pwd = properties.getProperty(&quot;pwd&quot;); System.out.println(&quot;用户名 = &quot; + user); System.out.println(&quot;密码 = &quot; + pwd); &#125;&#125;/*运行结果：-- listing properties --user=rootpwd=12345ip=192.168.100.100root12345*/ 修改文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.io.FileOutputStream;import java.io.FileWriter;import java.io.IOException;import java.util.Properties;/** * @author: 86199 * @date: 2023/5/8 20:52 * @description: */public class Properties03 &#123; public static void main(String[] args) throws IOException &#123; //load加载的时候加载到properties对象，是继承了hashtable的， // 所以相同key的就替换value了 //使用Properties类 来创建 配置文件，修改配置文件内容 Properties properties = new Properties(); //创建 //1. 如果该文件没有这个key，就是创建 //2. 如果该文件有这个key，就是修改 /* Properties 父类是 Hashtable，底层就是Hashtable 核心方法 public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value;//如果 key 存在，就替换 return old; &#125; &#125; addEntry(hash, key, value, index);//如果是新k，就addEntry return null; &#125; */ properties.setProperty(&quot;charset&quot;, &quot;utf8&quot;); properties.setProperty(&quot;user&quot;,&quot;汤姆&quot;);//注意中文保存时，是保存中文的 unicode码 properties.setProperty(&quot;pwd&quot;,&quot;888888&quot;); //将k-v 存储到文件中即可 properties.store(new FileOutputStream(&quot;src\\\\mysql2.properties&quot;), null); System.out.println(&quot;保存配置文件成功~~&quot;); &#125;&#125; mysql2.properties文件内容： 12345#Mon May 08 21:16:41 CST 2023user=\\u6C64\\u59C6pwd=888888charset=utf8","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"mysql-存储函数","slug":"mysql-存储函数","date":"2023-05-08T07:35:53.000Z","updated":"2023-05-13T09:43:11.298Z","comments":true,"path":"803d30ed.html","link":"","permalink":"http://example.com/803d30ed.html","excerpt":"","text":"存储函数==存储函数==是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下： 123456CREATE FUNCTION 存储函数名称([参数列表])RETURNS type [characteristic ...]BEGIN -- SQL语句 RETURN ...;END; characteristic说明： DETERMINISTIC：相同的输入参数总是产生相同的结果； NO SQL：不包含SQL语句； READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。 代码演示： 123456789101112131415161718-- 存储函数-- 从1到n的累加CREATE FUNCTION fun1(n INT)RETURNS INT DETERMINISTICBEGIN DECLARE total INT DEFAULT 0; WHILE n &gt; 0 DO SET total := total + n; SET n := n - 1; END WHILE; RETURN total;END;SELECT fun1(10);","categories":[{"name":"mysql学习","slug":"mysql学习","permalink":"http://example.com/categories/mysql%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"p10 打印流","slug":"p10-打印流","date":"2023-05-07T14:19:46.000Z","updated":"2023-05-13T09:43:11.307Z","comments":true,"path":"3aacf741.html","link":"","permalink":"http://example.com/3aacf741.html","excerpt":"","text":"打印流PrintStream 和 PrintWriter 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.IOException;import java.io.PrintStream;/** * @author: 86199 * @date: 2023/5/7 21:17 * @description: 演示字节打印流/输出流 PrintStream */public class PrintStream_ &#123; public static void main(String[] args) throws IOException &#123; //System.out 在 Java 中也是一个 final 对象引用， // 但它的初始化是在 Java 虚拟机启动时完成的，被初始化为一个指向标准输出流的对象。 //指向的地址不能修改，这个指向的对象本身可以被修改 PrintStream out = System.out; //在默认情况下，PrintStream 输出数据的位置是 标准输出 即显示器 out.print(&quot;Hello World!&quot;); //因为print()的底层本身就是write()，所以我们可以直接调用write()进行打印/输出 /* 源码 public void print(String s) &#123; if (s == null) &#123; s = &quot;null&quot;; &#125; write(s); &#125; */ out.write(&quot;Hello World!&quot;.getBytes()); out.close(); //我们可以修改打印流输出的位置/设备 System.setOut(new PrintStream(&quot;e:\\\\f1.txt&quot;)); System.out.println(&quot;Hello World!&quot;);//会输出到文件中 /* public static void setOut(PrintStream out) &#123; checkIO(); setOut0(out);//native方法，修改了out &#125; */ &#125;&#125; 1234567891011121314151617181920import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;/** * @author: 86199 * @date: 2023/5/7 21:51 * @description: 演示 PrintWriter 使用方式 */public class PrintWriter_ &#123; public static void main(String[] args) throws IOException &#123;// PrintWriter printWriter = new PrintWriter(System.out); PrintWriter printWriter = new PrintWriter(new FileWriter(&quot;e:\\\\f2.txt&quot;)); printWriter.print(&quot;三国演义 very good!&quot;); //不关闭流数据就不会输出 printWriter.close(); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"p9 转换流-InputStreamReader 和 OutputStreamWriter","slug":"p9-转换流-InputStreamReader-和-OutputStreamWriter","date":"2023-05-07T14:18:02.000Z","updated":"2023-05-13T09:43:11.321Z","comments":true,"path":"941525aa.html","link":"","permalink":"http://example.com/941525aa.html","excerpt":"","text":"转换流-InputStreamReader 和 OutputStreamWriter 介绍 InputStreamReader：Reader的子类，可以将InputStream（字节流）包装成Reader（字符流）； OutputStreamWriter：Writer的子类，实现将OutputStream（字节流）包装成Writer（字符流）； 当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流； 可以在使用时指定编码格式（比如 utf-8，gbk，gb2312，ISO8859-1等），解决乱码问题； InputStreamReader 代码演示： 123456789101112131415161718192021import java.io.*;/** * @author: 86199 * @date: 2023/5/7 17:18 * @description: 演示使用 InputStreamReader 转换流解决中文乱码问题 * 将字节流 FileInputStream 转换成字符流 InputStreamReader，指定编码 gbk/utf-8 */public class InputStreamReader_ &#123; public static void main(String[] args) throws IOException &#123; String filePath = &quot;e:\\\\a.txt&quot;; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(filePath), &quot;gbk&quot;)); //读取 String s = bufferedReader.readLine(); System.out.println(&quot;读取内容 = &quot; + s); //关闭流 bufferedReader.close(); &#125;&#125; OutputStreamWriter 代码演示： 123456789101112131415161718192021222324package com.hsp.transformation;import java.io.*;/** * @author: 86199 * @date: 2023/5/7 17:31 * @description: 演示 OutputStreamWriter 使用，把FileOutputStream 字节流，转成OutputStreamWriter * 指定处理的编码 gbk/utf-8/utf8 */public class OutputStreamWriter_ &#123; public static void main(String[] args) throws IOException &#123; String filePath = &quot;e:\\\\test.txt&quot;; String charSet = &quot;utf8&quot;; OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(filePath), charSet); outputStreamWriter.write(&quot;只因你太美&quot;); outputStreamWriter.close(); System.out.println(&quot;文件按照&quot; + charSet + &quot;保存成功&quot;); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"p8 标准输入输出流","slug":"p8-标准输入输出流","date":"2023-05-07T14:17:03.000Z","updated":"2023-05-13T09:43:11.319Z","comments":true,"path":"a4b4e77f.html","link":"","permalink":"http://example.com/a4b4e77f.html","excerpt":"","text":"标准输入输出流 流 编译类型 运行类型 默认设备 System.in 标准输入 InputStream BufferedInputStream 键盘 System.in 标准输出 PrintStream PrintStream 显示器 代码演示： 123456789101112131415161718192021222324252627282930import java.util.Scanner;/** * @author: 86199 * @date: 2023/5/7 16:11 * @description: */public class InputAndOutput &#123; public static void main(String[] args) &#123; //System类 的public final static InputStream in = null; //System.in 编译类型 InputStream //System.in 运行类型 BufferedInputStream //表示标准输入 键盘 System.out.println(System.in.getClass()); //System.out： public final static PrintStream out = null; //System.out 编译类型 PrintStream //System.out 运行类型 PrintStream //表示的时标准输出 显示器 System.out.println(System.out.getClass()); System.out.println(&quot;Hello World&quot;); Scanner scanner = new Scanner(System.in); System.out.println(&quot;输入内容：&quot;); String next = scanner.next(); System.out.println(&quot;next = &quot; + next); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"p7 对象流-ObjectInputStream 和 ObjectOutputStream","slug":"p7-对象流-ObjectInputStream-和-ObjectOutputStream","date":"2023-05-07T14:14:08.000Z","updated":"2023-05-13T09:43:11.323Z","comments":true,"path":"4a64dcab.html","link":"","permalink":"http://example.com/4a64dcab.html","excerpt":"","text":"对象流ObjectInputStream和ObjectOutputStream引言 看一个需求 将int num=100这个 int 数据保存到文件中，注意不是 100 数字，而是 int 100，并且，能够从文件中直接恢复 int 100； 将Dog dog = new Dog(“小黄”，3)这个dog对象保存到文件中，并且能够从文件恢复； 上面的要求，就是能够将 基本数据类型 或者 对象 进行 序列化 和 反序列化 操作； 序列化和反序列化 序列化就是在保存数据时，保存数据的值和数据类型； 反序列化就是在恢复数据时，恢复数据的值和数据类型； 需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一： Serializable：这是一个标记接口，没有方法 Externalizable：该接口有方法需要实现，因此我们一般实现上面的Serializable 基本介绍 功能：提供了对基本类型或对象类型的序列化和反序列化的方法； ObjectOutputStream 提供 序列化功能； ObjectInputStream 提供 反序列化功能； ObjectOutputStream 代码演示： 123456789101112131415161718192021222324252627282930import java.io.*;/** * @author: 86199 * @date: 2023/5/5 21:51 * @description: 演示ObjectOutputStream的使用，完成数据的序列化 */public class ObjectOutputStream_ &#123; public static void main(String[] args) throws IOException &#123; //序列化后，保存的文件格式，不是纯文本，而是按照序列化自己规定的格式来保存 String filePath = &quot;e:\\\\data.dat&quot;; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath)); //序列化数据到 e:\\data.dat oos.writeInt(100);//int -&gt; Integer（实现了 Serializable） oos.writeBoolean(true);//boolean -&gt; Boolean（实现了 Serializable） oos.writeChar(&#x27;a&#x27;);//char -&gt; Character（实现了 Serializable） oos.writeDouble(9.5);//double -&gt; Double（实现了 Serializable） oos.writeUTF(&quot;红楼梦&quot;);//String //保存一个dog对象 oos.writeObject(new Dog(&quot;旺财&quot;,10)); //关闭流 oos.close(); System.out.println(&quot;数据保存完毕（序列化形式）&quot;); &#125;&#125; Dog类代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.io.Serializable;/** * @author: 86199 * @date: 2023/5/5 23:09 * @description: *///如果需要序列化某个对象，实现 Serializablepublic class Dog implements Serializable &#123; private String name; private int age; //序列化对象时，默认将里面所有的属性都进行序列化，但除了static或transient修饰的成员 private static String nation; private transient String color; //序列化对象化时，要求里里面的属性的类型也必须实现序列化接口 private Master master = new Master(); //serialVersionUID 序列化的版本号，可以提高兼容性 //这样对该类进行修改后，进行序列化或者反序列化时就不会认为该类 //是全新的类，只是进行了版本更新 private static final long serialVersionUID = 1L; public Dog(String name, int age, String nation, String color) &#123; this.name = name; this.age = age; this.color = color; this.nation = nation; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, color = &#x27;&quot; + color + &#x27;\\&#x27;&#x27; + &quot;, nation = &#x27;&quot; + nation + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27; + &quot; &quot; + master; &#125;&#125; ObjectInputStream 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;import com.hsp.outputstream_.Dog;/** * @author: 86199 * @date: 2023/5/5 22:28 * @description: 演示ObjectInputStream的使用，完成数据的反序列化 */public class ObjectInputStream_ &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //指定反序列化的文件 String filePath = &quot;e:\\\\data.dat&quot;; //反序列化时，要保证和序列化时的信息是一致的，若被序列化的数据的类信息有改动，此时直接反序列化自然会出错，需要重新序列化数据(如果Dog加了serialVersionUID就不会报错) ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath)); //读取 //读取（反序列化）的顺序需要和保存数据（序列化）的顺序一致，否则会出现异常 System.out.println(ois.readInt()); System.out.println(ois.readBoolean()); System.out.println(ois.readChar()); System.out.println(ois.readDouble()); System.out.println(ois.readUTF()); Object dog = ois.readObject();//底层Object -&gt; Dog System.out.println(&quot;运行类型 = &quot; + dog.getClass()); System.out.println(&quot;dog信息 = &quot; + dog); //要想使用 我们这个反序列化来的Dog对象，还得使Dog可以在这被引用，然后向下转型 //1. 如果我们希望调用Dog的方法，需要向下转型 //2. 需要我们将Dog类的定义，放在可以引用的位置 Dog dog2 = (Dog)dog; System.out.println(dog2.getName()); //关闭流 ois.close(); &#125;&#125;/*运行结果100truea9.5红楼梦运行类型 = class com.hsp.outputstream_.Dogdog信息 = Dog&#123;name=&#x27;旺财&#x27;, age=10, color = &#x27;null&#x27;, nation = &#x27;null&#x27;&#125; com.hsp.outputstream_.Master@66a29884旺财*/","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"p6 BufferedInputStream 和 BufferedOutputStream","slug":"p6-BufferedInputStream-和-BufferedOutputStream","date":"2023-05-07T14:06:14.000Z","updated":"2023-05-13T09:43:11.316Z","comments":true,"path":"dd2d5e65.html","link":"","permalink":"http://example.com/dd2d5e65.html","excerpt":"","text":"BufferedInputStream 和 BufferedOutputStream BufferedInputStream BufferedInputStream是字节流，在创建BufferedInputStream时，会创建一个内部缓冲区数组。 构造方法摘要 Constructor and Description BufferedInputStream(InputStream in)创建一个 BufferedInputStream并保存其参数，输入流 in ，供以后使用。 BufferedInputStream(InputStream in, int size)创建 BufferedInputStream具有指定缓冲区大小，并保存其参数，输入流 in ，供以后使用。 方法摘要 Modifier and Type Method and Description int available()返回从该输入流中可以读取（或跳过）的字节数的估计值，而不会被下一次调用此输入流的方法阻塞。 void close()关闭此输入流并释放与流相关联的任何系统资源。 void mark(int readlimit)见的总承包 mark的方法 InputStream 。 boolean markSupported()测试这个输入流是否支持 mark和 reset方法。 int read()见 read法 InputStream的一般合同。 int read(byte[] b, int off, int len)从给定的偏移开始，将字节输入流中的字节读入指定的字节数组。 void reset()见 reset法 InputStream的一般合同。 long skip(long n)见 skip法 InputStream的一般合同。 BufferedOutputStream BufferedOutputStream是==字节流==，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统。 Constructor and Description BufferedOutputStream(OutputStream out)创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 BufferedOutputStream(OutputStream out, int size)创建一个新的缓冲输出流，以便以指定的缓冲区大小将数据写入指定的底层输出流。 Modifier and Type Method and Description void flush()刷新缓冲输出流。 void write(byte[] b, int off, int len)从指定的字节数组写入 len个字节，从偏移 off开始到缓冲的输出流。 void write(int b)将指定的字节写入缓冲的输出流。","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"p5 节点流 和 处理流","slug":"p5-节点流-和-处理流","date":"2023-05-04T14:44:08.000Z","updated":"2023-05-13T09:43:11.318Z","comments":true,"path":"769f414f.html","link":"","permalink":"http://example.com/769f414f.html","excerpt":"","text":"节点流 和 处理流 节点流和处理流一览图： ​ 【图片来源】http://t.csdn.cn/d52a1 基本介绍 节点流：节点流可以从一个特定的数据源==读写数据==，如FIleReader、FileWriter 处理流：处理流（也叫包装流）是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，也更加灵活，如BufferedReader、BufferedWriter。使用了修饰器设计模式。就是面向对象的封装思想，消除不同数据之间的差异性，仅对外暴露接口。 节点流 和 处理流 的区别和联系 节点流是底层流/低级流，直接跟数据源相接。 处理流（包装流）包装结点流，即可以消除不同节点的实现差异，也可以提供更方便的方法来完成输入输出。 处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * @author * @version 1.0 * 模拟修饰器设计模式 */public class Test_ &#123; public static void main(String[] args) &#123; BufferedReader_ bufferedReader_ = new BufferedReader_(new FileReader_()); bufferedReader_.readFiles(10); //希望通过BufferedReader_ 多次读取字符串 BufferedReader_ bufferedReader_1 = new BufferedReader_(new StringReader_()); bufferedReader_1.readStrings(5); &#125;&#125;abstract class Reader_ &#123; public void readFile_()&#123;&#125; public void readString_()&#123;&#125; //在Reader_抽象类，使用read方法统一管理// public abstract void read(); //后面在调用时就，利于对象动态绑定机制，绑定到对应的实现子类即可。&#125;// 模拟节点流class FileReader_ extends Reader_&#123; public void readFile_()&#123; System.out.println(&quot;对文件进行读取……&quot;); &#125;// public void read()&#123;// System.out.println(&quot;对文件进行读取……&quot;);// &#125;&#125;//模拟节点流class StringReader_ extends Reader_&#123; public void readString_()&#123; System.out.println(&quot;读取字符串……&quot;); &#125;// public void read()&#123;// System.out.println(&quot;读取字符串……&quot;);// &#125;&#125;//模拟处理流/包装流class BufferedReader_ extends Reader_&#123; //注意装饰器模式中，装饰类和被装饰类（约定俗成，而非必须）继承自同一个父类。 private Reader_ reader_;//属性是 Reader_ //接收Reader_子类对象 public BufferedReader_(Reader_ reader_) &#123; this.reader_ = reader_; &#125; public void readFile()&#123; reader_.readFile_(); &#125; //让方法更灵活，多次读取文件，或者加缓冲char[].... public void readFiles(int num)&#123; for (int i = 0; i &lt; num; i++) &#123; reader_.readFile_(); &#125; &#125; //扩展 readString，批量处理字符串数据 public void readStrings(int num)&#123; for (int i = 0; i &lt; num; i++) &#123; reader_.readString_(); &#125; &#125;&#125; 处理流的功能主要体现在以下两个方面： 性能的提高：主要以增加缓冲的方式来提高输入和输出的效率。 操作的便捷：处理流提供了一系列便捷的方法来一次输入输出大批量的数据就，使用更加灵活方便。 处理流 — BufferedReader和BufferedWriter BufferedReader 和 BufferedWriter属于字符流，是按照字符来读取数据的； 关闭处理流，只需关闭外层流即可，关闭外层流（包装流）时会自动关闭包装的节点流； BufferedReader 和 BufferedWriter 是安装字符操作，不要去操作二进制文件，可能造成文件损坏； BufferedReader 构造方法摘要 Constructor and Description BufferedReader(Reader in)创建使用默认大小的输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz)创建使用指定大小的输入缓冲区的缓冲字符输入流。 方法摘要 Modifier and Type Method and Description void close()关闭流并释放与之相关联的任何系统资源。 Stream&lt;String&gt; lines()返回一个 Stream ，其元素是从这个 BufferedReader读取的行。 void mark(int readAheadLimit)标记流中的当前位置。 boolean markSupported()告诉这个流是否支持mark（）操作。 int read()读一个字符 int read(char[] cbuf, int off, int len)将字符读入数组的一部分。 String readLine()读一行文字。 boolean ready()告诉这个流是否准备好被读取。 void reset()将流重置为最近的标记。 long skip(long n)跳过字符 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;/** * @author * @version 1.0 * 演示BufferedReader的使用 */public class BufferedReader_ &#123; public static void main(String[] args) throws IOException &#123; String filePath = &quot;e:\\\\a.java&quot;; //创建BufferedReader对象 BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath)); //读取 String line;//按行读取，效率高 //1. bufferedReader.readLine() 是按行读取文件 //2. 当返回null时，表示文件读取完毕 while((line = bufferedReader.readLine()) != null)&#123; System.out.println(line); &#125; //关闭流 //这里注意，只需关闭 BufferedReader(外层流)，因为底层会自动的去关闭节点流 FileReader /** * public void close() throws IOException &#123; * synchronized (lock) &#123; * if (in == null) * return; * try &#123; * in.close(); * &#125; finally &#123; * in = null;// in 就是我们传入的 new FileReader(filePath)，关闭了 * cb = null; * &#125; * &#125; * &#125; */ bufferedReader.close(); &#125;&#125; BufferedWriter 构造方法摘要 Constructor and Description BufferedWriter(Writer out)创建使用默认大小的输出缓冲区的缓冲字符输出流。 BufferedWriter(Writer out, int sz)创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区。 方法摘要 Modifier and Type Method and Description void close()关闭流，先刷新。 void flush()刷新流。 void newLine()写一行行分隔符。 void write(char[] cbuf, int off, int len)写入字符数组的一部分。 void write(int c)写一个字符 void write(String s, int off, int len)写一个字符串的一部分。 代码演示： 12345678910111213141516171819import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class BufferedWriter_ &#123; public static void main(String[] args) throws IOException &#123; String filePath = &quot;e:\\\\BufferedWriter_.java&quot;; BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePath, true)); bufferedWriter.write(&quot;hello, 你好&quot;); //插入一个和系统 相关的换行 bufferedWriter.newLine();// bufferedWriter.write(&quot;\\r\\n&quot;); bufferedWriter.write(&quot;hello, 你好&quot;); //关闭外层流即可，传入的节点流会自动关闭 bufferedWriter.close(); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"p4 FileReader 和 FileWriter","slug":"p4-FileReader-和-FileWriter","date":"2023-05-04T14:37:01.000Z","updated":"2023-05-13T09:43:11.315Z","comments":true,"path":"c1a7681b.html","link":"","permalink":"http://example.com/c1a7681b.html","excerpt":"","text":"FileReader 和 FileWriterFileReader 和 File Writer 介绍FileReader 和 FileWriter 是字符流，即按照字符来操作 io FileReader 相关方法 构造方法摘要 Constructor and Description FileReader(File file)创建一个新的 FileReader ，给出 File读取。 FileReader(String fileName)创建一个新的 FileReader ，给定要读取的文件的名称。 FileReader(FileDescriptor fd)创建一个新的 FileReader ，给定 FileDescriptor读取。 相关方法摘要 Modifier and Type Method and Description int read()每次读取单个字符，返回该字符，如过达到文件末尾返回-1 int read(char[])批量读取多个字符到数组中，返回读取到的字符数，如过达到文件末尾返回-1 相关API： new String(char[])：将char[]转换成String new String(char[], off, len)：将char[]的指定部分转换成String 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import org.junit.jupiter.api.Test;import java.io.FileReader;import java.io.IOException;/** * @author * @version 1.0 */public class FileReader_ &#123; public static void main(String[] args) &#123; &#125; /** * 单个字符读取 */ @Test public void fileReader01()&#123; String filePath = &quot;e:\\\\story.txt&quot;; //创建FileReader对象 FileReader fileReader = null; int data = 0; try &#123; fileReader = new FileReader(filePath); //循环读取 while((data = fileReader.read()) != -1)&#123; System.out.print((char)data); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(fileReader != null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 字符数组读取 */ @Test public void fileReader02()&#123; String filePath = &quot;e:\\\\story.txt&quot;; FileReader fileReader = null; int readLen = 0; char[] buf = new char[8]; try &#123; //创建FileReader对象 fileReader = new FileReader(filePath); //循环读取 while((readLen = fileReader.read(buf)) != -1)&#123; System.out.print((new String(buf, 0, readLen))); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(fileReader != null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; FileWriter 相关方法 构造方法摘要 Constructor and Description FileWriter(File file)给一个File对象构造一个FileWriter对象。 FileWriter(File file, boolean append)给一个File对象构造一个FileWriter对象。 FileWriter(String fileName)构造一个给定文件名的FileWriter对象。 FileWriter(String fileName, boolean append)构造一个FileWriter对象，给出一个带有布尔值的文件名，表示是否附加写入的数据。 FileWriter(FileDescriptor fd)构造与文件描述符关联的FileWriter对象。 相关方法摘要 Modifier and Type Method and Description void writer()写入单个字符 void writer(char[])写入指定数组 void writer(char[], int off, int len)写入指定数组的指定部分 void writer(String str)写入整个字符串 void writer(String str, int off, int len))写入字符串的指定部分 相关API：String类：toCharArray()：将String转换成char[] ==注意：FileWriter使用后，必须要关闭（close）或刷新（flush），否则写入不到指定的文件。==在Java中使用FileWriter进行文件写入时，数据首先被缓存在内存中。当缓冲区满或者close()或flush()方法被调用时，缓冲区中的数据才会被真正地写入到文件中。如果没有关闭流或者flush缓冲区，缓冲区中的数据就会一直保留在内存中，而不会被写入到文件中。如果程序突然崩溃或者关闭，这些缓冲的数据将会丢失，这可能会导致数据的不完整或者文件损坏。 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.io.FileWriter;import java.io.IOException;/** * @author * @version 1.0 */public class FileWriter_ &#123; public static void main(String[] args) &#123; String filePath = &quot;e:\\\\note.txt&quot;; FileWriter fileWriter = null; char[] chars = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; try &#123; //创建FileWriter对象 fileWriter = new FileWriter(filePath);//默认是覆盖写入 //这种构造方法在使用FileWriter时，如果文件不存在，则会自动创建一个新的文件， // 如果文件已经存在，则会直接打开该文件并清空原有内容，从文件的开头开始写入新的内容。 //1. writer(int)：写入单个字符 fileWriter.write(&#x27;H&#x27;); //2. writer(char[])：写入指定数组 fileWriter.write(chars); //3. writer(char[], off, len)：写入指定数组的指定部分 fileWriter.write(&quot;中国四大名著&quot;.toCharArray(), 0, 3); //4. writer(string)：写入整个字符串 fileWriter.write(&quot;猪八戒娶媳妇&quot;); //5.writer(string, off, len)：写入字符串的指定部分 fileWriter.write(&quot;三打白骨精&quot;,0,2); //在数据量大的情况下可以循环操作 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //对应FileWriter，一定要关闭流，或者flush才能真正的把数据写入文件中 //看源码就知道原因 /* 源码： private void writeBytes() throws IOException &#123; this.bb.flip(); int var1 = this.bb.limit(); int var2 = this.bb.position(); assert var2 &lt;= var1; int var3 = var2 &lt;= var1 ? var1 - var2 : 0; if (var3 &gt; 0) &#123; if (this.ch != null) &#123; assert this.ch.write(this.bb) == var3 : var3; &#125; else &#123; this.out.write(this.bb.array(), this.bb.arrayOffset() + var2, var3); &#125; &#125; this.bb.clear(); &#125; */ //在Java中使用FileWriter进行文件写入时，数据首先被缓存在内存中。当缓冲区满或者close()或flush()方法被调用时，缓冲区中的数据才会被真正地写入到文件中。 // //如果没有关闭流或者flush缓冲区，缓冲区中的数据就会一直保留在内存中， // 而不会被写入到文件中。如果程序突然崩溃或者关闭，这些缓冲的数据将会丢失， // 这可能会导致数据的不完整或者文件损坏。 try &#123; fileWriter.close(); //关闭文件流，等价于flush() + 关闭// fileWriter.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"p3 FileInputStream 和 FileOutputStream","slug":"p3-FileInputStream-和-FileOutputStream","date":"2023-05-04T14:33:32.000Z","updated":"2023-05-13T09:43:11.312Z","comments":true,"path":"53b48ec9.html","link":"","permalink":"http://example.com/53b48ec9.html","excerpt":"","text":"FileInputStream 和 FileOutputStream InputStream：字节输入流 InputStream抽象类是所有类输入流的超类 InputStream 常用的子类 FileInputStream： 文件输入流 BufferedInputStream：缓冲字节输入流 ObjectInputStream：对象字节输入流 FileInputStream 构造方法摘要 Constructor and Description FileInputStream(File file)通过打开与实际文件的连接创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(FileDescriptor fdObj)创建 FileInputStream通过使用文件描述符 fdObj ，其表示在文件系统中的现有连接到一个实际的文件。 FileInputStream(String name)通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 方法摘要 Modifier and Type Method and Description int available()返回从此输入流中可以读取（或跳过）的剩余字节数的估计值，而不会被下一次调用此输入流的方法阻塞。 void close()关闭此文件输入流并释放与流相关联的任何系统资源。 protected void finalize()确保当这个文件输入流的 close方法没有更多的引用时被调用。 FileChannel getChannel()返回与此文件输入流相关联的唯一的FileChannel对象。 FileDescriptor getFD()返回表示与此 FileInputStream正在使用的文件系统中实际文件的连接的 FileDescriptor对象。 int read()从该输入流读取一个字节的数据。 int read(byte[] b)从该输入流读取最多 b.length个字节的数据为字节数组。 int read(byte[] b, int off, int len)从该输入流读取最多 len字节的数据为字节数组。 long skip(long n)跳过并从输入流中丢弃 n字节的数据。 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import org.junit.jupiter.api.Test;import java.io.FileInputStream;import java.io.IOException;/** * @author * @version 1.0 */public class FileInputStream_ &#123; public static void main(String[] args) &#123; &#125; /** * 演示读取文件 * read(byte b)单个字节的读取，效率较低 * 使用 read(byte[] b) 来读取 */ @Test public void readFile01()&#123; String filePath = &quot;e:\\\\hello.txt&quot;; int readData = 0; FileInputStream fileInputStream = null; try &#123; //创建 FileInputStream 对象，用于读取文件 fileInputStream = new FileInputStream(filePath); //从该输入流读取一个字节的数据。如果没有输入可用，此方法将阻止 //如果返回-1.表示读取完毕 while((readData = fileInputStream.read()) != -1)&#123; System.out.print((char)readData);//转成char显示 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; fileInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Test public void readFile02()&#123; String filePath = &quot;e:\\\\hello.txt&quot;; byte[] buf = new byte[8];//一次读8个字节 int readLen = 0; FileInputStream fileInputStream = null; try &#123; //创建 FileInputStream 对象，用于读取文件 fileInputStream = new FileInputStream(filePath);// 读取的字节数最多等于b的长度。// 令k为实际读取的字节数; 这些字节将存储在元素b[0]至b[ k -1] ，使元素b[ k ]至b[b.length-1]不受影响。// 返回读取到缓冲区的总字节数，或者如果没有更多的数据，因为已经到达流的末尾，则是 -1 。 while((readLen = fileInputStream.read(buf)) != -1)&#123; System.out.print(new String(buf, 0, readLen));//显示 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; fileInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/*运行结果 hello world hello world*/ FileOutputStream 构造方法摘要 Constructor and Description FileOutputStream(File file)创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(File file, boolean append)创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(FileDescriptor fdObj)创建文件输出流以写入指定的文件描述符，表示与文件系统中实际文件的现有连接。 FileOutputStream(String name)创建文件输出流以指定的名称写入文件。 FileOutputStream(String name, boolean append)创建文件输出流以指定的名称写入文件。 方法摘要 Modifier and Type Method and Description void close()关闭此文件输出流并释放与此流相关联的任何系统资源。 protected void finalize()清理与文件的连接，并确保当没有更多的引用此流时，将调用此文件输出流的 close方法。 FileChannel getChannel()返回与此文件输出流相关联的唯一的FileChannel对象。 FileDescriptor getFD()返回与此流相关联的文件描述符。 void write(byte[] b)将 b.length个字节从指定的字节数组写入此文件输出流。 void write(byte[] b, int off, int len)将 len字节从位于偏移量 off的指定字节数组写入此文件输出流。 void write(int b)将指定的字节写入此文件输出流。 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.junit.jupiter.api.Test;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;/** * @author * @version 1.0 */public class FileOutputStream_ &#123; public static void main(String[] args) &#123; &#125; @Test public void writeFile()&#123; String filePath = &quot;e:\\\\a.txt&quot;; FileOutputStream fileOutputStream = null; try &#123; String str = &quot;Hello World!&quot;; //得到FileOutputStream对象 //1. new FileOutputStream(filePath) 创建方式，写入内容会默认覆盖原来的内容 //2. new FileOutputStream(filePath, append) 创建方式，append 为ture，写入内容会默认追加至原来的内容后，否则就覆盖 fileOutputStream = new FileOutputStream(filePath, true); //写入一个字节 fileOutputStream.write(&#x27;H&#x27;); //写入字符串，str.getBytes() 可以把 字符串 -》字符数组 fileOutputStream.write(str.getBytes()); /* write(byte[] b, int off, int len) 将 len 字节从位于偏移量 off的指定字节数组写入文件输出流 */// fileOutputStream.write(str.getBytes(), 0, str.length()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"p2 IO流原理及流的分类","slug":"p2-IO流原理及流的分类","date":"2023-05-04T14:27:49.000Z","updated":"2023-05-13T09:43:11.310Z","comments":true,"path":"7eef035f.html","link":"","permalink":"http://example.com/7eef035f.html","excerpt":"","text":"Java IO流原理 I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理数据传输。如读/写文件，网络通讯等。 Java程序中，对于数据的输入/输出操作以”流（stream）“的方式进行。 java.io包下提供了各种”流“类和接口，用以获取不同种类的数据，并通过方法输入或输出数据。 输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。 输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。 流的分类 按操作数据单位不同分为：字节流（8bit）二进制文件适合，字符流（按字符）文本文件适合 按数据流的流向不同分为：输入流，输出流 按流的角色的不同分为：节点流，处理流/包装流 （1）Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生出来的。 （2）由这四个类派生出来的子类名称都是以其父类名作为子类名的后缀。 【图片来源：http://t.csdn.cn/c80Qi】 文件和流的关系： 文件是计算机管理数据的基本单位，同时也是应用程序保存和读取数据的一个重要场所。 流是字节序列的抽象概念，例如文件、输入/输出设备、内部进程通信管道等。流提供一种向后备存储器写入字节和从后备存储器读取字节的方式。 文件是流的载体，容器。","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"p1 文件的基本使用","slug":"p1-文件的基本使用","date":"2023-05-04T14:12:02.000Z","updated":"2023-05-13T09:43:11.303Z","comments":true,"path":"d549c55e.html","link":"","permalink":"http://example.com/d549c55e.html","excerpt":"","text":"文件的基本使用文件 什么是文件 文件是保存数据的地方，比如word文档，txt文件，excel文件……都是文件。即可以保存一张图片，也可以保持视频，声音…… 文件流 文件在程序中是以流的形式来操作的 流：数据在数据源（文件）和程序（内存）之间经历的路径 输入流： 数据从数据源（文件）到程序（内存）的路径 输出流：数据从程序（内存）到数据源（文件）的路径 常用的文件操作创建文件对象相关构造器和方法 new File(String pathName) ：根据路径构建一个File对象，类似绝对路径 new File(File parent, String child)：根据父目录文件夹和子路径构建，类似根据相对路径 new File(String parent, String child)：根据父目录 和 子路径构建 createNewFile()： 创建新文件 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.junit.jupiter.api.Test;import java.io.File;import java.io.IOException;/** * @author * @version 1.0 * 演示创建文件 */public class FileCreate &#123; public static void main(String[] args) &#123; &#125; //方式1 new File(String pathName)，类似根据绝对路径创建？ @Test public void create01()&#123; String pathName = &quot;e:\\\\news1.txt&quot;; File file = new File(pathName);//创建文件对象，此时只是有一个对象在jvm内存中 try &#123; file.createNewFile();//创建文件，这里才对磁盘做出操作，创建出文件 System.out.println(&quot;文件创建成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //方式2 new File(File parent, String child)，类似根据相对路径创建？ //根据父目录文件夹和子路径构建 @Test public void create02()&#123; File parentFile = new File(&quot;e:\\\\&quot;); String fileName = &quot;news2.txt&quot;; File file = new File(parentFile, fileName);//创建文件对象 try &#123; file.createNewFile();//创建文件 System.out.println(&quot;文件创建成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //方式3 new File(String parent, String child)，根据父目录 + 子路径构建 @Test public void create03()&#123;// String parentPath = &quot;e:\\\\&quot;; String parentPath = &quot;e:/&quot;;//也可以这么写 String fileName = &quot;news3.txt&quot;; File file = new File(parentPath, fileName); try &#123; file.createNewFile(); System.out.println(&quot;文件创建成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取文件的相关信息的方法 getName()，getAbsolutePath()，getParent()，length()，exists()，isFile()，isDirectory() 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.junit.jupiter.api.Test;import java.io.File;import java.io.IOException;public class FileInformation &#123; public static void main(String[] args) &#123; &#125; //获取文件信息 @Test public void info()&#123; //创建文件对象 File file = new File(&quot;e:\\\\news1.txt&quot;);//File对象只是一个路径，可能是文件也可能是目录（文件夹）// try &#123;// file.createNewFile();// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125; //获取文件名字 System.out.println(&quot;文件名字 = &quot; + file.getName()); //文件绝对路径 System.out.println(&quot;文件绝对路径 = &quot; + file.getAbsolutePath()); //文件父目录 System.out.println(&quot;文件父目录 = &quot; + file.getParent()); //文件大小 System.out.println(&quot;文件大小 = &quot; + file.length()); //文件是否存在 System.out.println(&quot;文件是否存在 = &quot; + file.exists()); //该对象对应的是不是文件 System.out.println(&quot;是不是一个文件 = &quot; + file.isFile()); //该对象对应的是不是目录 System.out.println(&quot;是不是一个目录 = &quot; + file.isDirectory()); &#125;&#125;/*运行结果：文件名字 = news1.txt文件绝对路径 = e:\\news1.txt文件父目录 = e:\\文件大小 = 18文件是否存在 = true是不是一个文件 = true是不是一个目录 = false*/ 目录的操作和文件删除 mkdir()：创建一级目录 mkdirs()：创建多级目录 delete()：删除空目录或文件 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import org.junit.jupiter.api.Test;import java.io.File;public class Directory_ &#123; public static void main(String[] args) &#123; &#125; //判断 e:\\\\news1.txt 是否存在，存在就删除 @Test public void m1()&#123; String filePath = &quot;e:\\\\news1.txt&quot;; File file = new File(filePath); if(file.exists())&#123; if(file.delete())&#123; System.out.println(filePath + &quot; 删除成功&quot;); &#125;else &#123; System.out.println(filePath + &quot; 删除失败&quot;); &#125; &#125;else &#123; System.out.println(&quot;文件不存在……&quot;); &#125; &#125; //判断 D:\\\\demo02 是否存在，存在就删除 //目录也是文件 @Test public void m2()&#123; String filePath = &quot;D:\\\\demo02&quot;; File file = new File(filePath); if(file.exists())&#123; if(file.delete())&#123; System.out.println(filePath + &quot; 删除成功&quot;); &#125;else &#123; System.out.println(filePath + &quot; 删除失败&quot;); &#125; &#125;else &#123; System.out.println(&quot;该目录不存在……&quot;); &#125; &#125; //判断D:\\\\demo\\\\a\\\\b\\\\c 目录是否存在，如果存在就提示已经存在，否则就创建 @Test public void m3()&#123; String directoryPath = &quot;D:\\\\demo\\\\a\\\\b\\\\c&quot;; File file = new File(directoryPath); if(file.exists())&#123; System.out.println(directoryPath + &quot;存在...&quot;); &#125;else &#123; if (file.mkdirs())&#123;//创建一级目录用mkdir()，创建多级目录使用mkdirs() System.out.println(directoryPath + &quot;创建成功...&quot;); &#125;else&#123; System.out.println(directoryPath + &quot;创建失败...&quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"mysql-存储过程","slug":"mysql-存储过程","date":"2023-05-02T07:33:39.000Z","updated":"2023-05-13T09:43:11.300Z","comments":true,"path":"e845031c.html","link":"","permalink":"http://example.com/e845031c.html","excerpt":"","text":"存储过程介绍存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用，类似于函数或者说API，封装了系列操作，暴露接口给你进行操作。 特点 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 基本语法 创建 1234CREATE PROCEDURE 存储过程名称([参数列表])BEGIN -- SQL语句END; 调用 1CALL 名称([参数]); 查看 1234-- 查询指定数据库的存储过程及状态信息SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#x27;数据库名称&#x27;;-- 查询某个存储过程的定义SHOW CREATE PROCEDURE 存储过程名称; 删除 1DROP PROCEDURE [IF EXISTS] 存储过程名称; ==注意：在命令行中，执行创建存储过程的SQL语句时，需要通过关键字 delimiter 指定SQL语句的结束符。== 代码演示： 123456789101112131415161718192021222324252627-- 存储过程基本语法-- 创建CREATE PROCEDURE p1()BEGIN SELECT COUNT(*) FROM emp;END;-- 如果在命令行执行的话，上面语句会出错，因为遇到第一个分号就结束了，-- 所以需要用到 delimiter-- delimiter $$ --表示指定 $$ 为结束符（记得之后再使用delimiter改回来）-- CREATE PROCEDURE p1()-- BEGIN-- SELECT COUNT(*) FROM emp;-- END;$$-- 这样就可以解决-- 调用CALL p1();-- 查看SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#x27;hsp_db02&#x27;;SHOW CREATE PROCEDURE p1;-- 删除DROP PROCEDURE IF EXISTS p1; 变量 系统变量 ==系统变量==是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（==GLOBAL==）、会话变量（==SESSION==）。 查看系统变量 123456-- 查看所有系统变量SHOW [SESSION|GLOBAL] VARIABLES;-- 可以通过LIKE模糊匹配方式查找变量、SHOW [SESSION|GLOBAL] VARIABLES LIKE &#x27;......&#x27;;-- 查看指定变量的值SELECT @@[SESSION|GLOBAL] 系统变量名; 设置系统变量 12SET [SESSION|GLOBAL] 系统变量名 = 值;SET @@[SESSION|GLOBAL]系统变量名 = 值; 注意： 如果没有指定是session或global，则默认是session，会话变量。 mysql服务重新启动后，所设置的全局参数会失效，要想不失效，可以在/etc/my.cnf中配置 代码演示： 123456789101112131415-- 变量：系统变量-- 查看系统变量show variables; -- 所有系统变量show session variables; -- 会话变量show global variables; -- 全局变量show session variables like &#x27;auto%&#x27;;show global variables like &#x27;auto%&#x27;;select @@global.autocommit;select @@session.autocommit;-- 设置系统变量set session autocommit = 0; -- 设置为0，代表关闭了当前会话的事务的自动提交set global autocommit = 0; -- 当服务器重启后，这个参数又会初始化为默认值，想要不失效，需要在etc/my.cnf中配置 用户定义变量 ==用户定义变量== 是用户根据需要自己定义的变量，用户不用提前声明，在用的时候直接用 “@变量名”使用就可以。其作用域为当前连接（会话）。 赋值 12SET @var_name = expr[,@var_name = expr]...;SET @var_name := expr[,@var_name := expr]...; 12SELECT @var_name := expr[,@var_name := expr]...;SELECT 字段名 INTO @var_name FROM 表名; 使用 1SELECT @var_name; 注意：用户定义的变量是无需对其进行声明或初始化的，只不过获取到的值为NULL。 代码演示： 1234567891011121314-- 变量：用户变量-- 赋值SET @myname = &#x27;itcast&#x27;;SET @myage := 10; -- 推荐set @mygender := &#x27;男&#x27;, @myhobby := &#x27;java&#x27;;SELECT @mycolor := &#x27;red&#x27;;SELECT COUNT(*) into @mycount FROM demo;-- 使用SELECT @myname, @myage, @mygender, @myhobby;SELECT @mycolor, @mycount;SELECT @abc; -- NULL 局部变量 ==局部变量==是根据需要定义在局部生效的变量，访问之前，需要DECLARE声明。可以用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN … END块中。 声明 1DECLARE 变量名 变量类型[DEFAULT ...]; 变量类型就是数据库字段类型：INT、BiGINT、CHAR、VARCHAR、DATE、TIME等。 赋值 123SET 变量名 = 值;SET 变量名 := 值;SELECT 字段名 INTO 变量名 FROM 表名...; 代码演示： 123456789101112-- 变量：局部变量-- 声明 declare-- 赋值CREATE PROCEDURE p2()BEGIN DECLARE stu_count INT DEFAULT 0; set stu_count := 100; SELECT COUNT(*) into stu_count FROM demo; SELECT stu_count;END;CALL p2(); if判断语法： 1234567IF 条件1 THEN ......ELSEIF 条件2 THEN -- 可选 ......ELSE -- 可选 ......END IF; 代码演示： 1234567891011121314151617CREATE PROCEDURE p1()BEGIN DECLARE score INT DEFAULT 58; DECLARE `result` VARCHAR(10); IF score &gt;= 85 THEN SET `result` := &#x27;优秀&#x27;; ELSEIF score &gt;= 60 THEN SET `result` := &#x27;及格&#x27;; ELSE SET `result` := &#x27;不及格&#x27;; END IF; SELECT `result`;END;CALL p1(); 参数 类型 含义 备注 IN 因为该类参数作为输入，也就是需要调用时传入值 默认 OUT 因为该类参数作为输出，也就是该类参数可以作为作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数 用法： 1234CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型])BEGIN -- SQL语句END; 代码演示： 123456789101112131415161718192021222324CREATE PROCEDURE p2(IN score INT, OUT `result` VARCHAR(10))BEGIN IF score &gt;= 85 THEN SET `result` := &#x27;优秀&#x27;; ELSEIF score &gt;= 60 THEN SET `result` := &#x27;及格&#x27;; ELSE SET `result` := &#x27;不及格&#x27;; END IF;END;CALL p2(68, @result);SELECT @result;CREATE PROCEDURE p3(INOUT score INT)BEGIN set score := score / 2;END;SET @score := 120;CALL p3(@score);SELECT @score; case 语法一 12345CASE case_value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list]END CASE; 语法二 12345CASE WHEN search_condition1 THEN statement_list1 [WHEN search_condition2 THEN statement_list2] [ELSE statement_list]END CASE; 代码演示： 1234567891011121314151617181920CREATE PROCEDURE p4(in month int)BEGIN declare result varchar(10); case when month &gt;= 1 and month &lt;= 3 THEN set result := &#x27;第一季度&#x27;; when month &gt;= 4 and month &lt;= 6 THEN set result := &#x27;第二季度&#x27;; when month &gt;= 7 and month &lt;= 9 THEN set result := &#x27;第三季度&#x27;; when month &gt;= 10 and month &lt;= 12 THEN set result := &#x27;第四季度&#x27;; else SET result := &#x27;非法参数&#x27;; END case; SELECT concat(&#x27;您输入的月份为：&#x27;, month, &#x27; 所属的季度为：&#x27;, result);END;CALL p4(4); 循环 循环－while while循环是有条件的循环控制语句，满足条件后在执行循环体内的SQL语句，具体语法如下： 1234#先判定条件，如果条件为true，则执行逻辑，否则不执行逻辑WHILE 条件 DO -- SQL逻辑END WHILE; 代码演示： 123456789101112#计算1到n的累加值CREATE procedure p5(in n int)BEGIN DECLARE total int DEFAULT 0; WHILE n &gt; 0 do set total := total + n; set n := n - 1; END WHILE; SELECT total;END;call p5(10); 循环－repeat repeat是有条件的循环控制语句，直到满足条件的时候退出循环。具体语法如下： 12345#先执行一次逻辑，然后判定是否满足条件，如果满足则退出，不满足，继续进行下一次循环REPEAT -- SQL逻辑 -- UNTIL 条件END REPEAT; 代码演示： 12345678910111213#计算1到n的累加值CREATE procedure p6(in n int)BEGIN DECLARE total int DEFAULT 0; repeat set total := total + n; set n := n - 1; UNTIL n &lt;= 0 end REPEAT; SELECT total;END;call p6(10); 循环－loop LOOP实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。LOOP可以配合以下两个语句使用： LEAVE：配合循环使用，退出循环。 ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。123[begin_label:] LOOP -- SQL逻辑END LOOP [end_label]; 12LEAVE label; -- 退出指定标记的循环体ITERATE label; -- 直接进入下一次循环 代码演示：1234567891011121314151617#计算1到n的累加值CREATE procedure p7(in n int)BEGIN DECLARE total int DEFAULT 0; `sum`:LOOP if n &lt;= 0 THEN Leave `sum`; END if; set total := total + n; set n := n - 1; end LOOP sum; SELECT total;END;call p7(10); #计算1到n中的偶数的累加值 CREATE procedure p8(in n int) BEGIN DECLARE total int DEFAULT 0; `sum`:LOOP if n &lt;= 0 THEN Leave `sum`; END if; IF n % 2 = 1 THEN set n := n - 1; iterate `sum`; end if; set total := total + n; set n := n - 1; end LOOP sum; SELECT total; END; call p8(10); 1234567891011121314151617181920212223242526272829303132333435363738394041## **游标**游标（CURSOR）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下：- 声明游标 `DECLARE 游标名称 CURSOR FOR 查询语句;`- 打开游标 `OPEN 游标名称;`- 获取游标记录 `FETCH 游标名称 INTO 变量[,变量];`- 关闭游标 `CLOSE 游标名称````mysqlCREATE procedure p1(in uage int)BEGIN DECLARE u_name varchar(32); DECLARE u_profession varchar(32); DECLARE u_cursor CURSOR for SELECT name, profession FROM `user` where age &lt;= uage; -- DECLARE exit handler for sqlstate &#x27;02000&#x27; CLOSE u_cursor; DECLARE exit handler for Not FOUND CLOSE u_cursor; DROP TABLE if exists user_pro; CREATE TABLE user_pro( id int PRIMARY key AUTO_INCREMENT, name varchar(32), profession varchar(32) ); OPEN u_cursor; WHILE true do FETCH u_cursor INTO u_name, u_profession; INSERT into user_pro VALUES(null, u_name, u_profession); end WHILE;end;CALL p1(25);SELECT * from user_pro; user表：| id | name | age | profession || —- | ——– | —- | ———- || 1 | 孙悟空 | 20 | java || 2 | 猪八戒 | 21 | php || 3 | 沙和尚 | 22 | C || 4 | 唐僧 | 19 | C++ || 5 | 观音 | 24 | C# || 6 | 佛祖 | 30 | js || 7 | 玉皇大帝 | 31 | ts || 8 | 西王母 | 29 | python || 9 | 哪吒 | 15 | go | user_pro表：| id | name | profession || —- | —— | ———- || 1 | 孙悟空 | java || 2 | 猪八戒 | php || 3 | 沙和尚 | C || 4 | 唐僧 | C++ || 5 | 观音 | C# || 6 | 哪吒 | go | 条件处理程序-handler==条件处理程序（Handler）==可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤，具体语法如下： 1DECLARE handler_action HANDLER FOR condition_value[,condition_value]... statement; handler_action： CONTINUE：继续执行当前程序 EXIT：终止执行当前程序 condition_value： SQLSTATE sqlstate_value：状态码，如02000； SQLWARNING：所有以01开头的SQLSTATE代码的简写； NOT FOUND：所有以02开头的SQLSTATE代码的简写； SQLEXCEPTION：所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE代码的简写","categories":[{"name":"mysql学习","slug":"mysql学习","permalink":"http://example.com/categories/mysql%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-05-01T13:10:31.346Z","updated":"2023-05-13T09:43:11.296Z","comments":true,"path":"4a17b156.html","link":"","permalink":"http://example.com/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"mysql学习","slug":"mysql学习","permalink":"http://example.com/categories/mysql%E5%AD%A6%E4%B9%A0/"},{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]}