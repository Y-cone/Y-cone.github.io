{"meta":{"title":"Y博客","subtitle":"","description":"记录自己学习笔记的博客","author":"yc","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-05-02T17:57:53.771Z","updated":"2023-05-02T17:57:53.771Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2023-05-02T17:48:34.122Z","updated":"2023-05-02T17:48:34.122Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-05-02T17:49:22.543Z","updated":"2023-05-02T17:49:22.543Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-05-02T17:48:56.287Z","updated":"2023-05-02T17:48:56.287Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"暂时没想好"},{"title":"","date":"2023-05-02T17:50:46.107Z","updated":"2023-05-02T17:50:46.107Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"JDBC p6 ApDBUtils","slug":"JDBC-p6-ApDBUtils","date":"2023-07-26T09:22:05.000Z","updated":"2023-07-26T09:27:56.903Z","comments":true,"path":"df585e0e.html","link":"","permalink":"http://example.com/df585e0e.html","excerpt":"","text":"ApDBUtils引出问题分析： 关闭 connection 之后，resultSet 结果集无法使用。 resultSet 不利于数据的管理 示意图： 自己完成封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.hspedu.jdbc.datasource;import org.junit.jupiter.api.Test;import java.sql.*;import java.util.ArrayList;public class JDBCUtilsByDruid_test &#123; // 使土方法解决ResultSet 封装 =&gt; ArrayList @Test public void testSelectToArrayList()&#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; String sql = &quot;select * from actor where id &gt;= ?&quot;; ArrayList&lt;Actor&gt; actors = new ArrayList&lt;&gt;(); try &#123; connection = JDBCUtilsByDruid.getConnection(); System.out.println(connection.getClass());//运行类型class com.alibaba.druid.pool.DruidPooledConnection preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, &quot;1&quot;); resultSet = preparedStatement.executeQuery(); // 如果在这里将connection关闭，接下来将会报错 // 因为resultSet结果集 是和connection关联的，connection关闭了结果集就不能用了，不利与多次复用// connection.close();//报错：java.sql.SQLException: Operation not allowed after ResultSet closed while (resultSet.next())&#123; int id = resultSet.getInt(&quot;id&quot;); String name = resultSet.getString(&quot;name&quot;); String sex = resultSet.getString(&quot;sex&quot;); Date borndate = resultSet.getDate(&quot;borndate&quot;); String phone = resultSet.getString(&quot;phone&quot;); //把得到的resultSet对象封装到 Actor对象，放入到list集合中 actors.add(new Actor(id, name, sex, borndate, phone)); &#125; System.out.println(&quot;actors集合数据 = &quot; + actors); for (Actor actor : actors) &#123; System.out.println(&quot;id&quot; + actor.getId()); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; //关闭 JDBCUtilsByDruid.close(resultSet, preparedStatement, connection); //因为ArrayList 和 connection 没有关联// return actors; &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JDBC p5 数据库连接池","slug":"JDBC-p5-数据库连接池","date":"2023-07-26T09:21:53.000Z","updated":"2023-07-26T09:27:56.900Z","comments":true,"path":"b441d19b.html","link":"","permalink":"http://example.com/b441d19b.html","excerpt":"","text":"数据库连接池传统获取Connection问题分析 传统的JDBC数据库使用 DriverManager 来获取， 每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证IP地址，用户名和密码（0.05 ~ 1 s 时间）。需要数据库连接的时候，就向数据库要求一个，频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃。 每一次数据库连接使用后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄漏，最终将导致重启数据库。 传统获取连接的方式，不能控制创建的连接数量，如果连接过多，也可能导致内存泄露，MySQL崩溃。 解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 案例： 123456789101112131415161718192021222324252627package com.hspedu.jdbc.datasource;import com.hspedu.jdbc.utils.JDBCUtils;import org.junit.jupiter.api.Test;import java.sql.Connection;public class ConQuestion &#123; //代码 连接mysql 5000次 @Test public void testCon()&#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 5000; i++)&#123; //使用传统jdbc连接方式 Connection connection = JDBCUtils.getConnection(); //可能会抛出too many connections的异常 //再看看，如果得到连接就立即关闭，总共会耗时多久 JDBCUtils.close(null, null, connection); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;耗时 = &quot; + (end - start));//耗时 = 6598 &#125;&#125; 数据库连接池原理 基本介绍 预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需要从“缓冲池”中取出一个，使用完毕之后再放回去（放回连接，其实就是指程序不再引用这个连接）。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 原理示意图： 常用的数据库连接池​ JDBC 的数据库连接池使用 javax.sql.DateSource 来表示，DataSource 只是一个接口，该接口通常由第三方提供实现。 数据库连接池种类：** ==C3P0== 数据库连接池：速度相对较慢，稳定性不错 （hibernate，spring）； DBCP 数据库连接池：速度相对C3P0较快，但不稳定； Proxool 数据库连接池：有监控连接池状态的功能，稳定性较C3P0差一点； BoneCP 数据库连接池：速度快； ==Druid（德鲁伊）== 数据库连接池：是阿里提供的数据库连接池，集DBCP、C3P0、Proxool优点于一身的数据库连接池； C3P0的使用需要自行导入相关的jar包。 方式1：相关参数，在程序中指定user，url， password。 方式2： 使用配置文件的模板来完成。 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.hspedu.jdbc.datasource;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.junit.jupiter.api.Test;import java.beans.PropertyVetoException;import java.io.FileInputStream;import java.io.IOException;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;public class C3P0_ &#123; //方式1：相关参数，在程序中指定user, url, password @Test public void testC3P0_01() throws IOException, PropertyVetoException, SQLException &#123; //1. 创建一个数据源对象 ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); //2. 通过配置文件获取相关连接信息 Properties properties = new Properties(); properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;)); String user = properties.getProperty(&quot;user&quot;); String password = properties.getProperty(&quot;password&quot;); String url = properties.getProperty(&quot;url&quot;); String driver = properties.getProperty(&quot;driver&quot;); //给数据源（数据源负责连接，连接池） comboPooledDataSource 设置参数 comboPooledDataSource.setDriverClass(driver); comboPooledDataSource.setJdbcUrl(url); comboPooledDataSource.setUser(user); comboPooledDataSource.setPassword(password); //设置初始化连接数 comboPooledDataSource.setInitialPoolSize(10); //最大连接数 comboPooledDataSource.setMaxPoolSize(50); //获取连接 //测试连接池的效率，连接5000次 long start = System.currentTimeMillis(); for (int i = 0; i &lt; 5000; i++) &#123; Connection connection = comboPooledDataSource.getConnection();//这个方法就是从DateSource接口实现的// System.out.println(&quot;连接OK&quot;); //关闭 connection.close(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;c3p0 5000次连接mysql 耗时 = &quot; + (end - start));//c3p0 5000次连接mysql 耗时 = 280，之前传统的耗时 = 6598 &#125; //第二种方式， 使用配置文件的模板来完成 //1. 将c3p0 提供的 c3p0.config.xml 拷贝到src目录 //2. 该文件指定了连接数据库和连接池的相关参数 @Test public void testC3P0_02() throws SQLException &#123; ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(&quot;hsp_edu&quot;);//填入数据源名称 long start = System.currentTimeMillis(); for (int i = 0; i &lt; 500000; i++) &#123; Connection connection = comboPooledDataSource.getConnection();//这个方法就是从DateSource接口实现的// System.out.println(&quot;连接OK&quot;); //关闭 connection.close(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;c3p0 第二种方式500000次连接mysql 耗时 = &quot; + (end - start));//c3p0 第二种方式500000次连接mysql 耗时 = 1452 &#125;&#125; 配置文件 c3p0-config.xml： 123456789101112131415161718192021&lt;c3p0-config&gt; &lt;named-config name=&quot;hsp_edu&quot;&gt; &lt;!-- 连接参数 --&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/jdbc_learning&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;!-- 每次增长的连接数 --&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt; &lt;!-- 初始的连接数 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;10&lt;/property&gt; &lt;!-- 最小连接数 --&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 每个连接对象可连接的最多的命令对象数 --&gt; &lt;property name=&quot;maxStatementPerConnection&quot;&gt;2&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; Druid（德鲁伊）的使用需要自行导入相关的jar包。 代码演示： 1234567891011121314151617181920212223242526272829303132333435package com.hspedu.jdbc.datasource;import com.alibaba.druid.pool.DruidDataSourceFactory;import org.junit.jupiter.api.Test;import javax.sql.DataSource;import java.io.FileInputStream;import java.sql.Connection;import java.util.Properties;public class Druid_ &#123; @Test public void testDruid() throws Exception &#123; //1. 加入 Druid jar包 //2. 加入 配置文件 druid.properties，将该文件拷贝到项目的src目录 //3. 创建 Properties 对象 Properties properties = new Properties(); properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;)); //4. 创建一个指定参数的数据库连接池 DataSource dataSource = DruidDataSourceFactory.createDataSource(properties); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 500000; i++) &#123; Connection connection = dataSource.getConnection();// System.out.println(&quot;连接成功&quot;); connection.close(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;druid连接池， 连接500000次 耗时 = &quot; + (end - start));//druid连接池， 连接500000次 耗时 = 549 &#125;&#125; 配置文件 druid.properties： 12345678910111213#key=valuedriverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbc_learning?rewriteBatchedStatements=trueusername=rootpassword=root#initial connection sizeinitialSize=10#min idle connection sizeminIdle=5#max active connection sizemaxActive=50#max wait time (5000 mil seconds)maxWait=5000","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JDBC p4 批处理","slug":"JDBC-p4-批处理","date":"2023-07-26T09:21:42.000Z","updated":"2023-07-26T09:27:56.901Z","comments":true,"path":"8b228c26.html","link":"","permalink":"http://example.com/8b228c26.html","excerpt":"","text":"批处理 基本介绍： 当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。 JDBC的批量处理语句包括下面方法： addBatch()：添加需要批量处理的SQL语句或参数； executeBatch()：执行批量处理语句； clearBatch()：清空批处理包的语句； JDBC连接MySQL时，如果要使用批处理功能，请在url中加入参数：==rewriteBatchedStatements=true==。 批处理往往和PreparedStatement一起搭配使用，可以即减少编译次数，又减少运行次数，效率大大提高。 批处理是将我们的SQL语句先存放在ArrayList中，当添加到指定的值后就executeBatch，批量处理。批处理会减少我们发送sql语句的网络开销，而且减少编译次数，因此效率提高。 案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.hspedu.jdbc.batch_;import com.hspedu.jdbc.utils.JDBCUtils;import org.junit.jupiter.api.Test;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;import java.sql.Statement;/** * @author: 86199 * @date: 2023/7/20 15:34 * Description: 演示Java 的 批处理 */public class Batch_ &#123; //传统方法添加数据到admin2表 @Test public void noBatch()&#123; //得到连接 Connection connection; PreparedStatement preparedStatement; try &#123; connection = JDBCUtils.getConnection(); String sql = &quot;insert into admin2 values (NULL, ?, ?)&quot;; preparedStatement = connection.prepareStatement(sql); System.out.println(&quot;开始执行&quot;); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 5000; i++) &#123; preparedStatement.setString(1, &quot;jack&quot; + i); preparedStatement.setString(2, &quot;666&quot;); //执行 preparedStatement.executeUpdate(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;传统方式 耗时 = &quot; + (end - start));//传统方式 耗时 = 4825 &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; //关闭资源 JDBCUtils.close(null, preparedStatement, connection); &#125; //使用批量方式添加数据 @Test public void batch()&#123; //得到连接 Connection connection; PreparedStatement preparedStatement; try &#123; connection = JDBCUtils.getConnection(); String sql = &quot;insert into admin2 values (NULL, ?, ?)&quot;; preparedStatement = connection.prepareStatement(sql); System.out.println(&quot;开始执行&quot;); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 5000; i++) &#123; preparedStatement.setString(1, &quot;jack&quot; + i); preparedStatement.setString(2, &quot;666&quot;); //将 sql语句加入批处理包 //执行 preparedStatement.addBatch(); //当有5000条时，再批量执行 if((i + 1) % 1000 == 0)&#123; preparedStatement.executeBatch(); //清空 preparedStatement.clearBatch(); &#125; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;批量包方式 耗时 = &quot; + (end - start));//批处理方式 耗时 = 87 &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; //关闭资源 JDBCUtils.close(null, preparedStatement, connection); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JDBC p3 事务","slug":"JDBC-p3-事务","date":"2023-07-26T09:21:22.000Z","updated":"2023-07-26T09:27:56.897Z","comments":true,"path":"f59cddf9.html","link":"","permalink":"http://example.com/f59cddf9.html","excerpt":"","text":"事务 基本介绍 JDBC 程序中当一个Connection对象创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 JDBC程序中为了多个SQL语句作为一个整体执行，需要==使用事务==。 调用 Connection 的 setAutoCommit(false) 可以取消自动提交事务（相当与开启了事务）。 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务。 在其中某个操作失败或出现异常时，调用 rollback(); 方法回滚事务。 案例：模拟经典的转账的业务 MySQL代码： 12345678910CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(32) NOT NULL DEFAULT &#x27;&#x27;, balance DOUBLE NOT NULL DEFAULT 0) CHARACTER SET utf8;INSERT INTO account VALUES(NULL, &#x27;马云&#x27;, 3000);INSERT INTO account VALUES(NULL, &#x27;马化腾&#x27;, 10000);SELECT * FROM account; Java代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.hspedu.jdbc.transaction_;import com.hspedu.jdbc.utils.JDBCUtils;import org.junit.jupiter.api.Test;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;/** * Description: 演示在jdbc 中如何使用事务 */public class Transaction_ &#123; //没有使用事务，模拟银行转账出现异常 @Test public void noTransaction()&#123; //1. 得到连接 Connection connection = null; //默认情况下，connection 默认自动提交， 执行一句sql语句，就会提交事务 //2. SQL语句 String sql = &quot;update account set balance = balance - 100 where id = ?&quot;; String sql2 = &quot;update account set balance = balance + 100 where id = ?&quot;; PreparedStatement preparedStatement = null; //3. 创建PreparedStatement 对象 try &#123; connection = JDBCUtils.getConnection(); preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1, 1); preparedStatement.executeUpdate(); int i = 1 / 0; //抛出异常接下来的语句就不会执行 preparedStatement = connection.prepareStatement(sql2); preparedStatement.setInt(1, 2); preparedStatement.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //关闭资源 JDBCUtils.close(null, preparedStatement, connection); &#125; &#125; //使用事务 @Test public void UseTransaction() &#123; //1. 得到连接 Connection connection = null; //默认情况下，connection 默认自动提交， 执行一句sql语句，就会提交事务 //2. SQL语句 String sql = &quot;update account set balance = balance - 100 where id = ?&quot;; String sql2 = &quot;update account set balance = balance + 100 where id = ?&quot;; PreparedStatement preparedStatement = null; //3. 创建PreparedStatement 对象 try &#123; connection = JDBCUtils.getConnection(); connection.setAutoCommit(false);//相当与开启了事务 preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1, 1); preparedStatement.executeUpdate(); int i = 1 / 0; //抛出异常接下来的语句就不会执行 preparedStatement = connection.prepareStatement(sql2); preparedStatement.setInt(1, 2); preparedStatement.executeUpdate(); //这里提交事务 connection.commit(); &#125; catch (SQLException | ArithmeticException e) &#123; System.out.println(&quot;执行发生了异常，撤销执行的SQL&quot;); e.printStackTrace(); //可以在这里进行回顾，即撤销执行的sql语句 try &#123; connection.rollback();//默认回滚到事务开始的时候，可以填入回滚点savePoint &#125; catch (SQLException ex) &#123; throw new RuntimeException(ex); &#125; &#125; finally &#123; //关闭资源 JDBCUtils.close(null, preparedStatement, connection); &#125; &#125;&#125; 模拟1号向2号转账100元转账异常，调用noTransaction()方法，不使用事务，可以发现结果如下： 发生异常后，1号的存款转出了 100元，2号没有收到100元，100元没了。 如果调用的是useTransaction()方法，使用事务（connection.setAutoCommit(false) 取消事务自动提交）结果如下： 没有变化，控制台打印了 “执行发生了异常，撤销执行的SQL”，出现了异常后try-catch并进行了事务的回滚","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JDBC p2 JDBC API","slug":"JDBC-p2-JDBC-API","date":"2023-07-26T09:21:07.000Z","updated":"2023-07-26T09:27:56.898Z","comments":true,"path":"ef8e6411.html","link":"","permalink":"http://example.com/ef8e6411.html","excerpt":"","text":"JDBC API获取数据库连接5种方式 通过new创建Driver对象； 使用反射加载Driver类，动态加载，减少依赖性，更加灵活； 使用DriverManager 替代 Driver 进行统一管理，有了更好的扩展性； 使用 Class.forName 自动完成注册驱动，简化代码； 在方式4的基础上改进，增加配置文件，让mysql连接更灵活，最推荐使用； 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.hspedu.jdbc;import com.mysql.jdbc.Driver;import org.junit.jupiter.api.Test;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.Properties;/** * 分析java连接mysql的5种方式 */public class JdbcConn &#123; //方式1 @Test public void connect01() throws SQLException &#123; Driver driver = new Driver(); String url = &quot;jdbc:mysql://localhost:3306/jdbc_learning&quot;; Properties properties = new Properties(); properties.setProperty(&quot;user&quot;, &quot;root&quot;);//用户名 properties.setProperty(&quot;password&quot;, &quot;root&quot;);//密码 Connection connection = driver.connect(url, properties); System.out.println(&quot;第一种方式&quot; + connection); connection.close(); &#125; //方式2 @Test public void connect02() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException &#123; //使用反射加载Driver类，动态加载，减少依赖性，更加灵活 Class&lt;?&gt; aClass = Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Driver driver = (Driver) aClass.newInstance(); String url = &quot;jdbc:mysql://localhost:3306/jdbc_learning&quot;; Properties properties = new Properties(); properties.setProperty(&quot;user&quot;, &quot;root&quot;);//用户名 properties.setProperty(&quot;password&quot;, &quot;root&quot;);//密码 Connection connection = driver.connect(url, properties); System.out.println(&quot;第二种方式&quot; + connection); connection.close(); &#125; //方式3 使用DriverManager 替代 Driver 进行统一管理，有了更好的扩展性 @Test public void connect03() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException &#123; //使用反射加载Driver类 Class&lt;?&gt; aClass = Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Driver driver = (Driver) aClass.newInstance(); String url = &quot;jdbc:mysql://localhost:3306/jdbc_learning&quot;; String user = &quot;root&quot;; String password = &quot;root&quot;; DriverManager.registerDriver(driver);//注册Driver驱动，DriverManager是Java自带的类 Connection connection = DriverManager.getConnection(url, user, password); System.out.println(&quot;第三种方式&quot; + connection); &#125; //方式4 使用 Class.forName 自动完成注册驱动，简化代码 //这种方式推荐使用，使用最多 @Test public void connect04() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException &#123; //使用反射加载Driver类 //在加载 Driver类时，完成注册 /* 源码：1. 静态代码块，在类加载时，会执行一次 2. 因此注册driver的工作在底层已经完成了 static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;); &#125; &#125; */ //1.mysqL驱动5.1.6可以无需CLass.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.从jdk1.5以后使用了jdbc4,不再需要显示调用class.forName()注册驱动而是自动调用驱动 //jar包下META-INF\\services\\java.sql.Driver文本中的类名称去注册 //3.建议还是写上CLass.forName(&quot;com.mysql.jdbc.Driver&quot;),更加明确 Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//内部有一段静态代码会默认自动注册 String url = &quot;jdbc:mysql://localhost:3306/jdbc_learning&quot;; String user = &quot;root&quot;; String password = &quot;root&quot;; Connection connection = DriverManager.getConnection(url, user, password); System.out.println(&quot;第四种方式&quot; + connection); &#125; //方式5 在方式4的基础上改进，增加配置文件，让mysql连接更灵活，最推荐使用 @Test public void connect05() throws IOException, ClassNotFoundException, SQLException &#123; //通过Properties对象获取配置文件的信息 Properties properties = new Properties(); properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;)); //获取相关的值 String user = properties.getProperty(&quot;user&quot;); String password = properties.getProperty(&quot;password&quot;); String driver = properties.getProperty(&quot;driver&quot;); String url = properties.getProperty(&quot;url&quot;); Class.forName(driver);//建议写上 Connection connection = DriverManager.getConnection(url, user, password); System.out.println(&quot;第五种方式&quot; + connection); &#125;&#125; 配置文件mysql.properties： 1234user=rootpassword=zylurl=jdbc:mysql://localhost:3306/jdbc_learningdriver=com.mysql.jdbc.Driver ResultSet[结果集] 基本介绍 表示数据库结果集的数据表，通常通过执行查询数据库的语句生成； ResultSet对象保持一个光标指向其当前的数据行。最初，光标位于第一行前； next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false，因此可以在while循环中使用循环来遍历结果集。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.hspedu.jdbc.resultset_;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.sql.*;import java.util.Properties;/** * @author: 86199 * @date: 2023/6/14 21:52 * Description: 演示select 语句 返回 ResultSet，并取出结果 */@SuppressWarnings(&#123;&quot;all&quot;&#125;)public class ResultSet_ &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, SQLException &#123; //通过Properties对象获取配置文件的信息 Properties properties = new Properties(); properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;)); //获取相关的值 String user = properties.getProperty(&quot;user&quot;); String password = properties.getProperty(&quot;password&quot;); String driver = properties.getProperty(&quot;driver&quot;); String url = properties.getProperty(&quot;url&quot;); //1. 注册驱动 Class.forName(driver);//建议写上 //2. 得到连接 Connection connection = DriverManager.getConnection(url, user, password); //3. 得到Statement Statement statement = connection.createStatement(); //组织sql语句 String sql = &quot;select id, name, sex, borndate from actor;&quot;; /* 1 周星驰 男 1970-11-11 00:00:00 110 2 刘德华 男 1970-11-11 00:00:00 110 3 刘德华 男 1970-11-11 00:00:00 110 */ //执行给定的SQL语句，该语句返回单个ResultSet对象 /* 源码： */ ResultSet resultSet = statement.executeQuery(sql); while (resultSet.next()) &#123;//让光标后移，如果没有更多行，则返回false int id = resultSet.getInt(1);//获取该行的第1列 String name = resultSet.getString(2);//获取该行的第2列 String sex = resultSet.getString(3); String date = resultSet.getString(4); System.out.println(id + &quot;\\t&quot; + name + &quot;\\t&quot; + sex + &quot;\\t&quot; + date); &#125; //关闭资源 resultSet.close(); statement.close(); connection.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344 ## Statement对象- **基本介绍** 1. Statement对象，用于执行静态SQL语句并返回其生成的结果的对象。 2. 在连接建立之后，需要对数据库进行访问，执行命名或是SQL语句，可以通过 - Statement [存在SQL注入] - ==PreparedStatement==（预处理） - CallableStatement（存储过程） 3. Statement对象执行SQL语句存在==SQL注入==的风险 - **SQL注入**是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令，恶意攻击数据库。 - 要防范 SQL注入，只要用 **PreparedStatement**（从Statement扩展而来）取代 Statement 就可以了。**MySQL代码：**​```mysql-- 演示sql注入-- 创建一张表CREATE TABLE admin ( -- 管理员表`name` VARCHAR(32) NOT NULL UNIQUE,pwd VARCHAR(32) NOT NULL DEFAULT &#x27;&#x27;) CHARACTER SET utf8;-- 添加数据INSERT INTO admin VALUES(&#x27;jac&#x27;, &#x27;123&#x27;);-- 查找某个管理员是否存在SELECT * FROM adminWHERE `name` = &#x27;tom&#x27; AND pwd = &#x27;123&#x27;;-- SQL注入-- 输入用户名 1&#x27; or-- 输入密码 为 or &#x27;1&#x27; = &#x27;1-- SELECT * -- FROM admin-- WHERE `name` = &#x27;&#x27; AND pwd = &#x27;&#x27;;SELECT * FROM adminWHERE `name` = &#x27;1&#x27; or&#x27; AND pwd = &#x27;or &#x27;1&#x27; = &#x27;1&#x27;; Java代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.hspedu.jdbc.statement_;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.sql.*;import java.util.Properties;import java.util.Scanner;/** * @author: 86199 * @date: 2023/6/15 22:24 * Description: 演示 SQL注入的问题 */public class Statement_ &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, SQLException &#123; Scanner scanner = new Scanner(System.in); //让用户输入管理员用户名和密码 System.out.print(&quot;请输入管理员名字：&quot;); String admin_name = scanner.nextLine(); System.out.print(&quot;请输入管理员密码：&quot;); String admin_pwd = scanner.nextLine(); //通过Properties对象获取配置文件的信息 Properties properties = new Properties(); properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;)); //获取相关的值 String user = properties.getProperty(&quot;user&quot;); String password = properties.getProperty(&quot;password&quot;); String driver = properties.getProperty(&quot;driver&quot;); String url = properties.getProperty(&quot;url&quot;); //1. 注册驱动 Class.forName(driver);//建议写上 //2. 得到连接 Connection connection = DriverManager.getConnection(url, user, password); //3. 得到Statement Statement statement = connection.createStatement(); //组织sql语句 String sql = &quot;SELECT name, pwd FROM admin where name = &#x27;&quot; + admin_name + &quot;&#x27; and pwd = &#x27;&quot; + admin_pwd + &quot;&#x27;;&quot;; ResultSet resultSet = statement.executeQuery(sql); if (resultSet.next()) &#123;//如果查询到一条记录，说明该管理员存在 System.out.println(&quot;恭喜，登录成功&quot;); &#125;else&#123; System.out.println(&quot;对不起，登录失败&quot;); &#125; resultSet.close(); statement.close(); connection.close(); &#125;&#125;//运行/*请输入管理员名字：1&#x27; or请输入管理员密码：or &#x27;1&#x27; = &#x27;1恭喜，登录成功*/ 预处理（查询和修改） PreparedStatement 执行的SQL语句中的参数用问号（?）来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数。setXxx() 方法有两个参数，第一个参数都是int，要设置SQL语句中的参数的索引（从 1 开始），第二个是设置的 SQL 语句中的参数的值。 调用 executeQuery()，返回 ResultSet 对象。 调用 executeUpdate()：执行更新，包括增，删，修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.hspedu.jdbc.preparedstatement_;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.sql.*;import java.util.Properties;import java.util.Scanner;/** * @author: 86199 * @date: 2023/7/17 20:43 * Description: 演示PreparedStatement使用 */public class PreparedStatement_ &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, SQLException &#123; Scanner scanner = new Scanner(System.in); //让用户输入管理员用户名和密码 System.out.print(&quot;请输入管理员名字：&quot;); String admin_name = scanner.nextLine(); System.out.print(&quot;请输入管理员密码：&quot;); String admin_pwd = scanner.nextLine(); //通过Properties对象获取配置文件的信息 Properties properties = new Properties(); properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;)); //获取相关的值 String user = properties.getProperty(&quot;user&quot;); String password = properties.getProperty(&quot;password&quot;); String driver = properties.getProperty(&quot;driver&quot;); String url = properties.getProperty(&quot;url&quot;); //1. 注册驱动 Class.forName(driver);//建议写上 //2. 得到连接 Connection connection = DriverManager.getConnection(url, user, password); //sql中的？就相当于占位符 String sql = &quot;SELECT name, pwd FROM admin where name = ? and pwd = ? ;&quot;; //3. 得到PreparedStatement，这里的statement是实现了PreparedStatement接口的实现类的对象 PreparedStatement statement = connection.prepareStatement(sql); //给 ？ 赋值 statement.setString(1, admin_name); statement.setString(2, admin_pwd); //执行sql语句，如果执行的是dml语句要用executeUpdate() ResultSet resultSet = statement.executeQuery();//()中不能再写sql语句，不然执行的就是带？的，填了sql语句就是调用了父类Statement的方法了 if (resultSet.next()) &#123;//如果查询到一条记录，说明该管理员存在 System.out.println(&quot;恭喜，登录成功&quot;); &#125;else&#123; System.out.println(&quot;对不起，登录失败&quot;); &#125; //关闭链接 resultSet.close(); statement.close(); connection.close(); &#125;&#125;//运行/*请输入管理员名字：1&#x27; or请输入管理员密码：or &#x27;1&#x27; = &#x27;1对不起，登录失败*/","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Servlet p8 文件的上传和下载","slug":"Servlet-p8-文件的上传和下载","date":"2023-07-04T08:59:56.000Z","updated":"2023-07-04T09:02:15.034Z","comments":true,"path":"50e83347.html","link":"","permalink":"http://example.com/50e83347.html","excerpt":"","text":"学习课程： 【这可能是B站讲的最好的Servlet教程，5小时打通Servlet全套教程丨2022最新版，轻松掌握servlet基础+案例实操】 https://www.bilibili.com/video/BV1Kr4y1V7ZE/?share_source=copy_web&amp;vd_source=2c07d62293f5003c919b2df9b2e0549e 文件的上传和下载在上网的时候我们常常遇到文件上传的情况，例如上传头像、上传资料等：当然除了上传，遇见下载的情况也很多，接下来看看我们servlet中怎么实现文件的上传和下载。 文件上传文件上传涉及到前台页面的编写和后台服务器端代码的编写，前台发送文件，后台接收并保存文件，这才是一个完整的文件上传。 前台页面在做文件上传的时候，会有一个上传文件的界面，首先我们需要一个表单，并目表单的请求方式为POST；其次我们的form表单的enctype必须设为 “multipart/form-data”,即enctype=”multipart/form-data”，意思是设置表单的类型为文件上传表单，默认情况下这个表单类型是 “application/.x-www-form-urlencoded”，不能用于文件上传，只有使用了multipart/form-data才能完整地传递文件数据。 前台页面代码： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 文件上传 1. 准备表单 2. 设置表单的提交类型为 POST请求， method=&quot;post&quot; 3. 设置表单的类型为文件上传表单 enctype=&quot;multipart/form-data&quot; 4. 设置文件提交的地址 5. 准备表单元素 1. 普通的表单项 type=&quot;text&quot; 2. 文件项 type=&quot;file&quot; 6. 设置表单元素的name属性值（表单提交一定要设置表单元素的name属性值，否则后台无法接收数据） --&gt; &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;uploadServlet&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;&lt;br&gt; 文件：&lt;input type=&quot;file&quot; name=&quot;myfile&quot;&gt;&lt;br&gt; &lt;!-- button按钮的默认类型是 submit--&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 后台实现使用注解 @MultipartConfig 将一个Servlet标识为支持文件上传。Servlet将multipart/form-data的POST请求封装成Part，通过Part对上传的文件进行操作。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import javax.servlet.ServletException;import javax.servlet.annotation.MultipartConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.Part;import java.io.IOException;/** * @author: 86199 * @date: 2023/7/3 15:34 * Description: 文件上传后台代码 */@WebServlet(&quot;/uploadServlet&quot;)@MultipartConfig //如果是文件上传，必须设置该注解public class uploadServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;文件上传....&quot;); //设置请求的编码格式 req.setCharacterEncoding(&quot;UTF-8&quot;); //获取普通表单项 String uname = req.getParameter(&quot;uname&quot;); System.out.println(&quot;uname = &quot; + uname); //文件上传表单 //获取part对象（Servlet 会将 multipart/form-data 的Post请求封装成一个Part对象） Part part = req.getPart(&quot;myfile&quot;); //获取文件名 String fileName = part.getSubmittedFileName(); System.out.println(&quot;上传文件名 &quot; + fileName); //文件存放路径 String realPath = req.getServletContext().getRealPath(&quot;/&quot;); System.out.println(&quot;文件存放路径：&quot; + realPath); //上传文件到指定目录 part.write(realPath + &quot;/&quot; + fileName); &#125;&#125; 文件下载文件下载文件下载，即将服务留上的资源下载（拷贝）到本地，我们可以通过两种方式下载。第一种是通过超链接本身的特性来下载；第二种是通过代码下载， 超链接下载当我们在HTML或SP页面中使用标签时，原意是希望能够进行跳转，但当超链接遇到浏览器不识别的资源时会自动下载：当遇见刘览器能够直接显示的资源，浏览器就会默认显示出来，比如txt、pg、jPg等。当然我们也可以通过download属性规定浏览器进行下载。但有些浏览器并不支持。 默认下载： 12&lt;!-- 当超时接遭到浏览器不识别的资时，会自动下载，遇到可识别会显示其内容 --&gt;&lt;a href=&quot;test.zip&quot;&gt;文本文件&lt;/a&gt; 指定download属性下载： 12&lt;!--当超接遇到浏览器识别的资源时，默认不会下载，但是通过down1oad属性可进行下载--&gt;&lt;a href=&quot;test.txt download&quot;&gt;文本文件&lt;/a download属性可以不写任何信息，会自动使用默认文件名，如果设置了download属性的值，则使用设置的值做为文件名。当用户打开浏览器点击链接的时候就会直接下载文件。 后台实现下载实现步骤： 需要同通过 response.setContentType 方法设置 Content-typpe 头字段的值，让浏览器无法使用某种方式或激活某个程序来处理的 MIME 类型，例如 “application/octet-stream” 或 “application/x-msdownload” 等。 需要通过 response.setHeader 方法设置 Content-Disposition 头的值为 “attachment;filename=文件名”。 读取需要下载的文件，调用 response.getOutputStream 方法向客户端写入附件内容。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.OutputStream;/** * @author: 86199 * @date: 2023/7/3 17:07 * Description: 后台代码实现文件下载 */@WebServlet(&quot;/downloadServlet&quot;)public class DownloadServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;文件下载...&quot;); //设置请求编码 req.setCharacterEncoding(&quot;UTF-8&quot;); //获取参数，获取要下载的文件名 String fileName = req.getParameter(&quot;fileName&quot;); //trim() 去除字符串前后的空格 if(fileName != null &amp;&amp; &quot;&quot;.equals(fileName.trim()))&#123; resp.setContentType(&quot;text/html;charset=UTF-8&quot;); resp.getWriter().write(&quot;请输入要下载的文件名&quot;); resp.getWriter().close(); return; &#125; //获取文件的存放路径 String filePath = req.getServletContext().getRealPath(&quot;/download/&quot;); File file = new File(filePath + fileName); //判断文件是否存在，并且是一个标准文件 if(file.exists() &amp;&amp; file.isFile())&#123; //设置响应类型为浏览器不能识别的 resp.setContentType(&quot;application/x-msdownload&quot;); //设置响应头 resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + fileName); //得到文件输入流 FileInputStream in = new FileInputStream(file); //得到字节输出流 ServletOutputStream out = resp.getOutputStream(); byte[] bytes = new byte[1024]; int readLen = 0; while ((readLen = in.read(bytes)) != -1)&#123; out.write(bytes, 0, readLen); &#125; in.close(); out.close(); &#125;else &#123; resp.setContentType(&quot;text/html;charset=UTF-8&quot;); resp.getWriter().write(&quot;文件不存在请重试...&quot;); resp.getWriter().close(); &#125; &#125;&#125;","categories":[{"name":"B站Servlet教程","slug":"B站Servlet教程","permalink":"http://example.com/categories/B%E7%AB%99Servlet%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}]},{"title":"Servlet p7 ServletContext对象","slug":"Servlet-p7-ServletContext对象","date":"2023-07-04T08:59:27.000Z","updated":"2023-07-04T09:02:15.038Z","comments":true,"path":"77753a3d.html","link":"","permalink":"http://example.com/77753a3d.html","excerpt":"","text":"学习课程： 【这可能是B站讲的最好的Servlet教程，5小时打通Servlet全套教程丨2022最新版，轻松掌握servlet基础+案例实操】 https://www.bilibili.com/video/BV1Kr4y1V7ZE/?share_source=copy_web&amp;vd_source=2c07d62293f5003c919b2df9b2e0549e ServletContext对象每一个 web 应用都有且仅有一个 ServletContext 对象，又称为 Application 对象，从名称中可知，该对象是与应用程序相关的。在WEB 容器启动时，会为每一个 WEB 应用创建一个对应的 ServletContex对象。 该对象有两大作用： 作为域对象来共享数据，此时数据在整个应用程序中共享； 该对象中保存了当前应用程序相关信息。例如可以通过getServerInfo()方法获取当前服务器信息，getRealPath(String path) 获取资源的真是路径等。 1234567//常用方法//获取服务器当前版本信息String serverInfo = req.getServletContext().getServerInfo();System.out.println(&quot;获取服务器当前版本信息 = &quot; + serverInfo);//获取项目的真实路径String realPath = req.getServletContpext().getRealPath(&quot;/&quot;);System.out.println(&quot;获取项目的真实路径 = &quot; + realPath); ServletContext对象的获取获取Servlet Context对象的途径有很多。比如： 通过request对象获取ServletContext servletContext1 = req.getServletContext(); 通过Session对象获取ServletContext servletContext2 = req.getSession().getServletContext(); 通过ServletConfig对象获取，在 Servlet 标准中提供了 ServletConfig 方法ServletContext servletContext3 = getServletConfig().getServletContext(); 直接获取ServletContext servletContext4 = getServletContext(); ServletContext域对象ServletContext也可当做域对像象来使用，通过向ServletContext中存取数据，可以使得整个应用程序共享某些数据。当然不建议存放过多数据，因为ServletContext中的数据一旦存储进去没有手动移除将会一直保存。 1234567891011//获取ServletContext对象ServletContext servletContext = request.getServletContext();//设置域对象servletContext.setAttribute(&quot;uname&quot;, &quot;admin&quot;);//获取指定名称的域对象String uname = (String) servletContext.getAttribute(&quot;uname&quot;);//移除域对象servletContext.removeAttribute(&quot;uname&quot;); Servlet的三大域对象 request域对象 三个中作用范围最小，在一次请求中有效。请求转发有效，重定向无效。 session域对象 在一次会话中有效，请求转发和重定向都有效，session销毁后失效。 servletContext域对象 三个中作用范围最大，在整个应用程序中有效。服务器关闭后失效。","categories":[{"name":"B站Servlet教程","slug":"B站Servlet教程","permalink":"http://example.com/categories/B%E7%AB%99Servlet%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}]},{"title":"Servlet p6 HttpSession对象","slug":"Servlet-p6-HttpSession对象","date":"2023-07-04T08:58:58.000Z","updated":"2023-07-04T09:02:15.030Z","comments":true,"path":"69b80dcd.html","link":"","permalink":"http://example.com/69b80dcd.html","excerpt":"","text":"学习课程： 【这可能是B站讲的最好的Servlet教程，5小时打通Servlet全套教程丨2022最新版，轻松掌握servlet基础+案例实操】 https://www.bilibili.com/video/BV1Kr4y1V7ZE/?share_source=copy_web&amp;vd_source=2c07d62293f5003c919b2df9b2e0549e HttpSession对象HttpSession对象是javax.servlet.http.HttpSession的实例，该接口井不像HttpServletRequest或HttpServletResponse还存在一个父接口，该接口只是一个纯粹的接口。这因为session本身就属于HTTP协议的范畴。 对于服务器而言，每个来连接到它的客户端都是一个Session，Servlet容器使用此接口创建HTTP客户端和HTTP服务器之间的会话。会话将保留指定的时间段，跨多个连接或来自用户的页面请求。一个会话通常对应于一个用户，该用户可能多次访问一个站点。可以通过此接口查看和操作有关的某个会话的信息，比如会话标识符、创建时间和最后一次访问时间。在整个Session中，最重要的就是属性的操作。 Session 无论客户端还是服务器端都可以感知到，若重新打开一个新的浏览器，则无法取得之前设置的Session，因为每一个Session只保存在当前的浏览器中，并在相关的页面取得。 Session 的作用就是为了标识一次会话，或者说确认一个用户；并且在一次会话（一个用户的多次请求）期间共享数据，我们可以通过 request.getSession()方法，来获取当前会话的Session对象。 1234567891011121314151617181920@WebServlet(&quot;/ser01&quot;)public class Session01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取Session对象，获取Session对象时，会先判断Session对象是否存在，如果存在则获取，不存在，则创建 HttpSession session = req.getSession(); //获取Session对象的会话标识符 System.out.println(session.getId()); //获取Session对象的创建时间 System.out.println(session.getCreationTime()); //获取最后一次访问时间 System.out.println(session.getLastAccessedTime()); //判断是否是新的Session对象 System.out.println(session.isNew()); &#125;&#125; 标识符JSESSIONIDSession既然是为了标识一次会话，那么此次会话就应该有一个唯一的标志，这个标志就是sessionld。 每当一次请求到达服务器，如果开启了会话（访问了session)，服务器第一步会查看是否从客户端回传一个名为JSESSIONID的cookie，如果没有则认为这是一次新的会话，会创建一个新的session对象，并用唯一的sessionld为此次会话做一个标志。如果有JESSIONID这个cookie回传，服务器则会根据JSESSIONID这个值去查看是否含有id为SESSION值的session对象，如果没有则认为是一个新的会话，重新创建个新的session对像，并标志此次会话：如果找到了相应的session对象，则认为是之前标志过的一次会话，返回该session对像，数据达到共享。 这里提到一个叫做JSESSIONID的cookie，这是一个比较特殊的cookie，当用户请求服务器时，如果访问了session，则服务器会创建一个名为JSESSIONID，值为获取到的session（无论是获取到的还是新创建的）的sessionld的cookie对象，并添加到response对象中，响应给客户端，有效时间为关闭浏览器。 ==所以Session的底层依赖Cookie来实现。== Session域对象Session 用来表示一次会话，在一次会话中数据是可以共享的，这时 session 作为域对象存在，可以通过 setAttribute(name, value)方法向域对象中添加数据，通过 getAttribute(name)从域对象中获取数据，可以通过 removeAtttribute(name)方法从域对象中移除数据。 1234567891011//获取Session对象HttpSession session = req.getSession(); //设置Session域对象session.setAttribute(&quot;uname&quot;, &quot;admin&quot;);//获取指定名称的Session域对象String uname = (String) request.getSession().getAttribute(&quot;uname&quot;);//移除Session域对象session.removeAttribute(&quot;uname&quot;); 数据存储在 Session 域对象中，当域对象不存在了，或者是两个不一样的 Session对象时，数据也就不能共享了。 Session对象的销毁默认到期时间当客户端第一次请求 servlet 并且操作 session 时， session 对象生成，Tomcat 中 session 默认的存活时间为 30 min，即你不操作界面的时间，一旦有操作，session就会重新计时。 那么 session 的默认时间可以改吗？答案是肯定的。 可以在 Tomcat 的 conf目录下的 web.xml 文件中进行修改。 1234&lt;!-- session 默认的最大不活动时间。单位：分钟。--&gt;&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 自己设定到期时间当然除了以上的修改方式外，我们也可以在程序中自己设定 session 的生命周期，通过 session.setMaxInactiveInterval(int) 来设定 session 的最大不活动时间，单位为秒。 1234//获取 session对象HttpSession session = req.getSession();//设置Session对象的最大不活动时间session.setMaxInactiveInterval(15);//15秒失效 当然我们也可以通过 getMaxInactiveInterval() 方法来查看当前 Session对象 的最大不活动时间。 12//获取Session对象的最大不活动时间System.out.println(&quot;Session对象的最大不活动时间&quot; + session.getMaxInactiveInterval()); 立刻失效或者我们也可以通过 session.invalidate( ) 方法让 session 立刻失效。 1session.invalidate(); 关闭浏览器从前面的JESSION可知道，session的底层依赖cookie实现，并且该cookie的有效时间为关闭浏览器，从而session在浏览器关闭时也相当于失效了（因为没有JSESSION再与之对应）。 关闭服务器当关闭服务器时，session销毁。 Session失效则意味着此次会话结束，数据共享结束。","categories":[{"name":"B站Servlet教程","slug":"B站Servlet教程","permalink":"http://example.com/categories/B%E7%AB%99Servlet%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}]},{"title":"Servlet p5 Cookie对象","slug":"Servlet-p5-Cookie对象","date":"2023-06-28T14:19:09.000Z","updated":"2023-07-04T09:01:46.673Z","comments":true,"path":"dfb6e268.html","link":"","permalink":"http://example.com/dfb6e268.html","excerpt":"","text":"学习课程： 【这可能是B站讲的最好的Servlet教程，5小时打通Servlet全套教程丨2022最新版，轻松掌握servlet基础+案例实操】 https://www.bilibili.com/video/BV1Kr4y1V7ZE/?share_source=copy_web&amp;vd_source=2c07d62293f5003c919b2df9b2e0549e Cookie对象Cookie是浏览器提供的一种技术，通过服务器的程序能将一些只须保存在客户端，或者在客户端进行处理的数据，放在本地的计算机上，不需要通过网络传输，因而提高网页处理的效率，并且能够减少服务器的负载，但是由于Cook是服务器端保存在客户端的信息，所以其安全性也是很差的。例如常见的记住密码侧可以通过Cookie来实现。 有一个专门操作Cookie的类javax.servlet.http.Cookie，随着服务器端的响应发送给客户端，保存在浏览器。当下次再访问服务器时把Cookie再带回服务器。 Cookie的格式：键值对用 “=” 链接，多个键值对间通过”;”隔开。 浏览器查看Cooki： Network -&gt; Headers Application -&gt; Cookies Cookie的创建和发送通过 new Cookie(“key”, “value”) 来创建一个 Cookie对象，要想要将 Cookie 随响应发送到客户端，需要先添加到 response对象 中，response.addCookie(cookie) 此时该 cookie对象 会随着响应发送到客户端。在浏览器上可以看见。 代码演示： 12345678910@WebServlet(&quot;/cookie01&quot;)public class Cookie01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //创建Cookie Cookie cookie = new Cookie(&quot;name&quot;, &quot;admin&quot;); //发送(响应)Cookie对象 resp.addCookie(cookie); &#125;&#125; Cookie的获取在服务器端只提供了一个 getCookies()的方法用来获取客户端传回的所有 cookie 组成的一个数组，如果需要获取单个 cookie 则需要通过遍历，getName()获取 Cookie 的名称，getValue() 获取 Cookie 的值。 代码演示： 123456789101112131415161718@WebServlet(&quot;/cookie02&quot;)public class Cookie02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取Cookie数组 Cookie[] cookies = req.getCookies(); //判断是否为空 if (cookies != null &amp;&amp; cookies.length &gt; 0)&#123; //遍历cookie数组 for (Cookie cookie : cookies) &#123; String name = cookie.getName(); String value = cookie.getValue(); System.out.println(&quot;名称 = &quot; + name + &quot; 值 = &quot; + value); &#125; &#125; &#125;&#125; Cookie设置到期时间除了Cookie的名称和内容外，我们还需要关心一个信息，到期时间，到期时间用来指定该cookie何时失效。默认为当前测览器关闭即失效。我们可以手动设定cook的有效时间（通过到期时间计算），通过setMaxAge(int time) 方法设定cookie的最大有效时间，以秒为单位。 到期时间的取值 负整数 若为负数，表示不存储该cookie。cookie的maxAge属性的默认值就是 -1，表示只在浏览器内存中存活。一旦关闭浏览器窗口，那么cookie就会消失。 正整数若大于0的整数，表示存储的秒数。表示cookie对象可存活指定的秒数。当生命大于0时，浏览器会把Cookie保存到硬盘上，就算关闭浏览器，就算重启客户端电脑，cookie也会存活相应的时间。 零若为0，表示删除该cookie。cookie生命等于0是一个特殊的值，它表示cookie被作废！也就是说，如果原来浏览器已经保存了这个Cookie，那么可以通过Cookie的setMaxAge(0)来删除这个Cookie。无论是在浏览器内存中，还是在客户端硬盘上都会删除这个Cookie。 代码演示 1234567891011121314151617181920@WebServlet(&quot;/cookie03&quot;)public class Cookie03 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //负整数 Cookie cookie = new Cookie(&quot;uname1&quot;, &quot;No.1&quot;); cookie.setMaxAge(-1); resp.addCookie(cookie); //正整数 Cookie cookie2 = new Cookie(&quot;uname2&quot;, &quot;No.2&quot;); cookie2.setMaxAge(30); resp.addCookie(cookie2); //负整数 Cookie cookie3 = new Cookie(&quot;uname3&quot;, &quot;No.3&quot;); cookie3.setMaxAge(0); resp.addCookie(cookie3); &#125;&#125; Cookie的注意点 Cookie保存在当前浏览器中。 在一般的站点中常常有记住用户名这样的操作，该操作只是将信息保存在本机上，换电脑以后这些信息就无效了，而且Cookie不能跨浏览器。 Cookie存中文问题 Cookie 中不能出现中文，如果有中文则通过 URLEncoder.encode() 进行编码，获取时通过URLDecoder.decoder()进行解码。 同名Cookie问题 如果服务器端发送重复的 Cookie，那么会覆盖原有的 Cookie。 浏览器存放的Cookie数量 不同的浏览器对 Cookie 也有限定，Cookie的存储是有上限的。Cookie是存储在客户端（浏览器）的，而且一般是由服务器端创建和设定。后期结合 Session 来实现回话跟踪。 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author: 86199 * @date: 2023/6/28 20:56 * Description: * Cookie的注意点： * 1. Cookie只能在当前浏览器中有效（不跨浏览器和电脑） * 2. Cookie不能存中文 * 如果一定要存中文，则需要通过URLEncoder.encode() * 3. 如果出现同名的Cookie对象，则会覆盖 * 4. Cookie的存储数量是有上限的，不同浏览器的上限不同，Cookie存储的大小是有效的，在4kb左右 */@WebServlet(&quot;/cookie04&quot;)public class Cookie04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //cookie存中文 String name = &quot;姓名&quot;; String value = &quot;张三&quot;; //编码 name = URLEncoder.encode(name); value = URLEncoder.encode(value); //创建Cookie对象 Cookie cookie = new Cookie(name, value); //发送cookie resp.addCookie(cookie); //获取Cookie数组 Cookie[] cookies = req.getCookies(); //非空判断 if (cookies != null &amp;&amp; cookies.length &gt; 0)&#123; //遍历 for (Cookie i : cookies) &#123; //解码 System.out.println(URLDecoder.decode(i.getName())); System.out.println(URLDecoder.decode(i.getValue())); &#125; &#125; //将原来已有的cookie对象重新设置 Cookie cookie2 = new Cookie(&quot;name&quot;, &quot;张三&quot;); resp.addCookie(cookie2); &#125;&#125; Cookie 的路径Cookie 的 setPath 设置 Cookie 的路径，这个路径直接决定了服务器的请求是否可以从浏览器中加载某些 Cookie。 cookie.setPath(&quot;/&quot;); 当前服务器下的任何项目资源都可以获取Cookie对象。 1234/*当前项目路径为：s01*/Cookie cookie01 = new Cookie(&quot;cookie01&quot;, &quot;cookie01&quot;);cookie01.setPath(&quot;/&quot;);resp.addCookie(cookie01); cookie.setPath(&quot;/当前项目&quot;); 当前项目下的任意资源可以获取Cookie对象，默认值，可以不用设置。 1234/*当前项目路径为：s01*/Cookie cookie02 = new Cookie(&quot;cookie02&quot;, &quot;cookie02&quot;);cookie02.setPath(&quot;/sc04&quot;);resp.addCookie(cookie02); cookie.setPath(&quot;/指定项目(可以非当前项目)&quot;); 指定项目下的资源可以获取 Cookie对象，只能在指定项目才能获取，就算是产生Cookie对象的项目也不行。 1234/*当前项目路径为：s01*/Cookie cookie03 = new Cookie(&quot;cookie03&quot;, &quot;cookie03&quot;);cookie03.setPath(&quot;/ser03&quot;);resp.addCookie(cookie02); cookie.setPath(&quot;/指定项目/指定资源&quot;); 指定目录下的资源才可以获取Cookie对象 1234/*当前项目路径为：s01*/Cookie cookie04 = new Cookie(&quot;cookie04&quot;, &quot;cookie4&quot;);cookie01.setPath(&quot;/sc04/cookie02&quot;);resp.addCookie(cookie04); 如果我们设置path，如果当前访问的路径包含了cookie的路径（当前访问路径在cookie路径基础上要比cookie的范围小），cookie就会加载到request对象之中。 cookie的路径指的是可以访问该cookie的顶层目录，该路径的子路径也可以访问该cookie。 ==总结：当访问的路径包含了 cookie 的路径时，则该请求将带上该cookie；如果访问路径不包含cookie路径，则该请求将不会带上该cookie。==","categories":[{"name":"B站Servlet教程","slug":"B站Servlet教程","permalink":"http://example.com/categories/B%E7%AB%99Servlet%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}]},{"title":"Servlet p4 HttpServletResponse对象","slug":"Servlet-p4-HttpServletResponse对象","date":"2023-06-28T14:18:33.000Z","updated":"2023-07-04T09:01:42.026Z","comments":true,"path":"b877068.html","link":"","permalink":"http://example.com/b877068.html","excerpt":"","text":"学习课程： 【这可能是B站讲的最好的Servlet教程，5小时打通Servlet全套教程丨2022最新版，轻松掌握servlet基础+案例实操】 https://www.bilibili.com/video/BV1Kr4y1V7ZE/?share_source=copy_web&amp;vd_source=2c07d62293f5003c919b2df9b2e0549e HttpServletResponse对象基本介绍​ Web服务器收到客户端的http请求，会针对每次请求，分别创建一个用于代表请求的 request对象 和代表响应的 response对象。 ​ request 和 response对象 代表请求和响应：获取客户瑞数据，需要通过request对象；向客户端输出数据需要通过response对象 ​ HttpServletResponse的主要功能用于服务器对客户端的请求进行响应，将Web服务器处理后的结果返回给客户端。service(O方法中形参接收的是HttpServletResponse接口的实例化对象，这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。 响应数据​ 接收客户端请求后，可以通过 HttpServletResponse对象 直接进行响应，响应时需要获取输出流。 有两种形式： getWriter()：获取字符流（只能响应字符） 1234//获取字符输出流PrintWriter writer = resp.getWriter();//输出数据writer.write(&quot;hello&quot;); getOutputStream()：获取字节流（能响应一切数据） 1234//获取字节输出流ServletOutputStream outputStream = resp.getOutputStream();//输出数据outputStream.write(&quot;hi&quot;.getBytes()); ==注意：二者不能同时使用，因为resp对象只能响应一次，再次调用就不存在了。== 响应乱码问题​ 在响应中，如果我们响应的内容中含有中文，则可能出现乱码。这是因为服务器响应的数据也会经过网络传输，f服务器端有一种编码方式，在客户端也存在一种编码方式，当两端使用的编码方式不同时则出现乱码。 getWriter()字符乱码问题 ​ 对于getWriter()获取到的字符流，响应中文必定出乱码，由于服务器端在进行编码时默认会使用1S0-8859-1格式的编码，该编码方式并不支持中文。 要解决该种乱码只能在服务器端告知服务器使用一种能够支持中文的编码格式，比如我们通常用的”UTF-8”。 response.setcharacterEncoding(&quot;UTF-8&quot;); 此时还只完成了一半的工作，要保证数据正确显示，还需要指定客户端的解码方式。 response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=UTF-8&quot;); 两端指定编码后，乱码就解决了。一句话：==保证发送端和接收端的编码一致。==； 1234567//设置服务端的编码response.setcharacterEncoding(&quot;UTF-8&quot;);//设置客户端的响应类型及编码response.setHeader(&quot;content-type&quot;,&quot;text/html;charset-UTF-8&quot;);//得到字符输出流Printwriter writer response.getwriter();writer.write(&quot;&lt;h2&gt;你好&lt;/h2&gt;&quot;); 以上两端编码的指定也可以使用一句替代，同时指定服务器和客户端 response.setcontentType(&quot;text/html;charset=UTF-8&quot;); getOutputStream()字符乱码问题 ​ 对于getOutputStream(0方式获取到的字节流，响应中文时，由于本身就是传输的字节，所以此时可能出现乱码，也可能正确显示。当服务器端给的字节恰好和客户端使用的编码方式一致时，则文本正确显示，否则出现乱码。无论如何我们都应该准确掌握服务器和客户端使用的是那种编码格式，不能留下不确定因素，以确保数据正确显示。 直接指定客户端和服务器使用的编码方式一致 response.setHeader(&quot;content-type&quot;,&quot;text/html;charset-UTF-8&quot;); 1234//设置客户端的编码及响应类型Servletoutputstream out response.getoutputstream();response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=UTF-8&quot;);out.write(&quot;&lt;h2&gt;&lt;/h2&gt;&quot;.getBytes(&quot;UTF-8&quot;)) 重定向​ 重定向是一种服务器指导，客户端的行为。客户端发出第一个请求，被服务器接收处理后，服务器会进行响应，在响应的同时，服务器会给客户端一个新的地址（下次请求的地址response.sendRedirect(url:)，当客户端接收到响应后，会立刻、马上、自动根据服务器给的新地址发起第二个请求，服务器接收请求并作出响应，重定向完成。 从描述中可以看出重定向当中有两个请求存在，并且属于客户端行为。 12//重定向跳转到servlet05response.sendRedirect(&quot;s05&quot;); 通过观察浏览器我们发现第一次请求获得的响应码为302，并且含有一个location头信息。并且地址栏最终看到的地址是和第一次请求地址不同的，地址栏已经发生了变化。 servlet04代码： 12345678910111213141516171819202122232425262728293031package com.xxxx.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author: 86199 * @date: 2023/6/17 10:36 * Description: 重定向 * 存在两次请求 * 地址栏会发生改变 * request对象不共享 */@WebServlet(&quot;/s04&quot;)public class Servlet04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Servlet04....&quot;); // 接收参数 String uname = req.getParameter(&quot;uname&quot;); System.out.println(&quot;servlet04 uname = &quot; + uname); //重定向跳转到05 resp.sendRedirect(&quot;s05&quot;); &#125;&#125; servlet05代码： 12345678910111213141516171819202122232425package com.xxxx.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author: 86199 * @date: 2023/6/17 10:36 * Description: 重定向 */@WebServlet(&quot;/s05&quot;)public class Servlet05 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Servlet05....&quot;); // 接收参数，无法拿到，毕竟s04和s05之间也没有共享req对象 String uname = req.getParameter(&quot;uname&quot;); System.out.println(&quot;servlet05 uname = &quot; + uname); &#125;&#125; 请求转发和重定向的区别请求转发和重定向比较 两者都可以进行跳转，根据实际需求选取。 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.xxxx.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author: 86199 * @date: 2023/6/17 10:36 * Description: 重定向和请求转发的区别 * 1. 请求转发的地址栏不会发生改变，重定向的地址栏会发生改变 * 2. 请求转发只有一次请求，重定向有两次请求 * 3. 请求转发时request对象可以共享，重定向不能共享 * 4. 请求转发是服务端的行为，重定向是客户端行为 * 5. 请求转发时的地址只能是当前站点下的（当前项目）资源，重定向时地址可以是任意地址 */@WebServlet(&quot;/s06&quot;)public class Servlet06 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Servlet06....&quot;); // 接收参数 String uname = req.getParameter(&quot;uname&quot;); System.out.println(uname); //设置request域对象 req.setAttribute(&quot;upwd&quot;, &quot;123456&quot;); //请求转发 req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req, resp); //重定向// resp.sendRedirect(&quot;index.jsp&quot;); //重定向跳转到百度// resp.sendRedirect(&quot;http://www.baidu.com&quot;); //请求转发到百度，404找不到// req.getRequestDispatcher(&quot;http://www.baidu.com&quot;); &#125;&#125; index.jsp文件代码： 12345678910111213141516171819202122232425262728&lt;%-- Created by IntelliJ IDEA. User: 86199 Date: 2023/6/16 Time: 11:11 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%-- Java脚本段--%&gt; &lt;% //获取参数 String uname = request.getParameter(&quot;uname&quot;); //获取request作用域 String upwd = (String) request.getAttribute(&quot;upwd&quot;); //输出内容 out.print(uname); out.print(&quot;================&quot;); out.print(upwd); %&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"B站Servlet教程","slug":"B站Servlet教程","permalink":"http://example.com/categories/B%E7%AB%99Servlet%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}]},{"title":"Servlet p3 HttpServletRequest对象","slug":"Servlet-p3-HttpServletRequest对象","date":"2023-06-28T14:18:10.000Z","updated":"2023-07-04T09:01:36.650Z","comments":true,"path":"e0454e8c.html","link":"","permalink":"http://example.com/e0454e8c.html","excerpt":"","text":"学习课程： 【这可能是B站讲的最好的Servlet教程，5小时打通Servlet全套教程丨2022最新版，轻松掌握servlet基础+案例实操】 https://www.bilibili.com/video/BV1Kr4y1V7ZE/?share_source=copy_web&amp;vd_source=2c07d62293f5003c919b2df9b2e0549e HttpServletRequest对象基本介绍​ HttpServletRequest对象：HttpServletRequest 对象专门用于封装 HTTP 请求消息，简称 request 对象。主要作用是用来接收客户端发送过来的请求信息，该对象是由Tomcat封装好传递过来。 ​ HttpServletRequest接口是ServletRequest的子接口。HTTP 请求消息分为请求行、请求消息头和请求消息体三部分，所以 HttpServletRequest 接口中定义了获取请求行、请求头和请求消息体的相关方法。 在HttpServletRequest对象在Service方法中由容器传入过来，无需自己创建。 ​ 接收请求常用方法 返回值类型 方法声明 描述 StringBuffer getRequestURL() 返回客服端发出请求时的完整URL String getRequestURI() 该方法用于获取请求行中的资源名称部分，即位于 URL 的主机和端口之后，参数部分之（URL 中“?”以前）的部分。 String getQueryString() 该方法用于获取请求行中的参数部分，也就是 URL 中“?”以后的所有内容。 String getMethod() 该方法用于获取 HTTP 请求方式（如 GET、POST 等）。 String getProtocol() 返回HTTP版本号。 String getContextPath() 返回当前 Servlet 所在的应用的名字（上下文）。对于默认（ROOT）上下文中的 Servlet，此方法返回空字符串””。 代码演示： 123456789101112131415161718192021222324252627282930313233343536package com.xxxx.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/s01&quot;)public class servlet01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /*常用方法*/ //输入的地址：http://localhost:8080/ser02/s01 //获取请求时的完整路径（从http开始，到 &quot;?&quot; 前面结束） String url = req.getRequestURL() + &quot;&quot;; System.out.println(&quot;请求时的完整路径：&quot; + url);//请求时的完整路径：http://localhost:8080/ser02/s01 //获取请求时的部分路径（从项目的站点名开始，到 &quot;?&quot; 前面结束） String uri = req.getRequestURI(); System.out.println(&quot;请求时的部分路径：&quot; + uri);//请求时的部分路径：/ser02/s01 //获取请求时的参数字符串（从 &quot;?&quot; 后面开始，到最后的字符串） String queryString = req.getQueryString(); System.out.println(&quot;请求时的参数字符串（从 \\&quot;?\\&quot; 后面开始，到最后的字符串）：&quot; + queryString);//请求时的参数字符串（从 &quot;?&quot; 后面开始，到最后的字符串）：null //获取请求方式（GET和POST） String method = req.getMethod(); System.out.println(&quot;获取请求方式（GET和POST）：&quot; + method);//获取请求方式（GET和POST）：GET //获取当前的协议版本 String protocol = req.getProtocol(); System.out.println(&quot;当前的协议版本：&quot; + protocol);//当前的协议版本：HTTP/1.1 //获取项目的站点名（项目的对外访问路径） String contextPath = req.getContextPath();//上下文路径 System.out.println(&quot;项目的站点名（项目的对外访问路径）：&quot; + contextPath);//项目的站点名（项目的对外访问路径）：/ser02 &#125;&#125; 获取请求参数 返回值类型 方法声明 描述 String getParameter(String name) 以字符串形式返回指定的请求参数的值，或者如果参数不存在则返回 null。 String[] getParameterValues(String name) 返回一个字符串对象的数组，包含所有指定的请求参数的值，如果参数不存在则返回 null。 代码演示： 123456789101112131415161718192021222324252627282930313233343536package com.xxxx.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/s01&quot;)public class servlet01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /*获取请求参数*/ //输入的地址：http://localhost:8080/ser02/s01?uname=abc&amp;upwd=123&amp;hobby=sing&amp;hobby=dance&amp;hobby=rap // 获取指定名称的参数值（重点！！！） String uname = req.getParameter(&quot;uname&quot;); String upwd = req.getParameter(&quot;upwd&quot;); System.out.println(&quot;uname：&quot; + uname + &quot;upwd：&quot; + upwd);//uname：abcupwd：123 //获取指定名称参数的所有参数值（通常用于复选框） String[] hobbies = req.getParameterValues(&quot;hobby&quot;); //判断数组是否为空 if (hobbies != null &amp;&amp; hobbies.length &gt; 0)&#123; for (String hobby : hobbies) &#123; System.out.println(&quot;爱好：&quot; + hobby); &#125; &#125; /* 爱好：sing 爱好：dance 爱好：rap */ &#125;&#125; 请求乱码问题 基本介绍 由于现在的request属于接收客户端的参数，所以必然有其默认的语言编码，主要是由于在解析过程中默认使用的编码方式为ISO-8859-1（此编码不支持中文），所以解析时一定会出现乱码。要想解决这种乱码问题，需要设置request中的编码方式，告诉服务器以何种方式来解析数据。或者在接收到乱码数据以后，再通过相应的编码格式还原。 实现方式 方式一：request.setcharacterEncoding(&quot;UTF-8&quot;);这种方式只针对POST有效（必须在接收所有的数据之前设定） 方式二：new string(request.getParameter(name).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);借助了String对象的方法，该种方式对任何请求有效，是通用的。 Tomcat8起，以后的GET方式请求是不会出现乱码的。 请求转发 基本介绍 请求转发，是一种服务器行为，当客户端请求达到后，服务器进行转发，此时会将请求对象进行保存，地址栏中的URL地址不会改变，得到响应后，服务器端再将响应发送个客服端，从始至终只有一个请求发出。 特点 服务器行为 地址栏不发生改变 从始至终只有一个请求发出 request数据可以共享 实现方式 req.getRequestDispatcher(url).forward(request, response); 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839package com.xxxx.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author: 86199 * @date: 2023/6/16 9:00 * Description: 请求转发，可以让请求从服务端跳转到客户端（或则跳转到指定Servlet） * * 特点： * 1. 服务端行为 * 2. 地址栏不发生改变 * 3. 从始至终都只有一个请求，s03的请求 * 4. req数据可以共享 */@WebServlet(&quot;/s03&quot;)public class Servlet03 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //接收客户端请求的参数 String uname = req.getParameter(&quot;uname&quot;); System.out.println(&quot;Servlet03 uname = &quot; + uname); //请求转发跳转到Servlet04（另一个Servlet对象）// req.getRequestDispatcher(&quot;s04&quot;).forward(req, resp); //请求转发跳转到jsp页面 req.getRequestDispatcher(&quot;login.jsp&quot;).forward(req, resp); //请求转发跳转到html页面 req.getRequestDispatcher(&quot;login.html&quot;).forward(req, resp); &#125;&#125; request作用域 基本介绍 通过该对象可以在请求中传递数据，作用范围：在一次请求中有效，即服务器跳转有效。 实现方式 123456//设置域对象内容request.setAttribute(String name, Object o);//获取域对象内容request.getAttribute(String name);//删除域对象内容request.removeAttribute(String name); request 域对象中的数据在一次请求中有效，经过请求转发，request域中的数据依然存在，即在请求转发的过程中可以通过 request 来传输/共享数据。 代码演示 123456789101112131415161718192021222324252627282930313233package com.xxxx.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;@WebServlet(&quot;/s05&quot;)public class Servlet05 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Servlet05...&quot;); //设置域对象内容 req.setAttribute(&quot;name&quot;, &quot;admin&quot;); req.setAttribute(&quot;age&quot;, 18); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;aaa&quot;); list.add(&quot;bbb&quot;); req.setAttribute(&quot;list&quot;, list); //请求转发// req.getRequestDispatcher(&quot;s06&quot;).forward(req, resp);//共用一个req对象，这里只能有一个请求转发 //请求转发跳转到jsp，并通过域对象传递数据 req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req, resp); &#125;&#125; index.jsp文件代码： 1234567891011121314151617181920212223242526&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: 86199 Date: 2023/6/12 Time: 11:28 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;index页面&lt;/h2&gt; &lt;%-- 如果要在jsp中写Java代码，需要写在脚本段中--%&gt; &lt;% //获取域对象内容 String name = (String) request.getAttribute(&quot;name&quot;); System.out.println(&quot;name = &quot; + name); Integer age = (Integer) request.getAttribute(&quot;age&quot;); System.out.println(&quot;age = &quot; + age); List&lt;String&gt; list = (List&lt;String&gt;) request.getAttribute(&quot;list&quot;); System.out.println(&quot;list = &quot; + list); %&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"B站Servlet教程","slug":"B站Servlet教程","permalink":"http://example.com/categories/B%E7%AB%99Servlet%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}]},{"title":"JDBC p1 JDBC概述","slug":"JDBC-p1-JDBC概述","date":"2023-06-12T14:44:11.000Z","updated":"2023-06-12T14:47:23.833Z","comments":true,"path":"8edf0808.html","link":"","permalink":"http://example.com/8edf0808.html","excerpt":"","text":"JDBC概述基本介绍 JDBC为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题。 Java程序员使用JDBC，可以连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的各种操作。 JDBC的基本原理： JDBC带来的好处JDBC 是Java提供的一套用于数据库操作的接口API，==Java程序员只需要面向这套接口编程即可==。不同的数据库厂商，需要针对这套接口，提供不同的实现。 JDBC APIJDBC API是一系列的接口，他统一和规范了应用程序与数据库的连接、执行SQL语句，并得到返回结果等各类操作，相关类和接口在 java.sql包 和 javax.sql包 中。 JDBC快速入门 注册驱动 - 加载Driver类 获取连接 — 得到Connection 执行增删改查 — 发送SQL 给MySQL执行 释放资源 - 关闭相关连接 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.hspedu.jdbc;import com.mysql.jdbc.Driver;import java.sql.Connection;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;/** * Jdbc程序，完成简单的操作 */public class Jdbc01 &#123; public static void main(String[] args) throws SQLException &#123; //前置工作： //在项目下创建一个文件夹比如libs //将mysql.jar拷贝到该目录下，点击add to project,加入到项目 //1. 注册驱动 Driver driver = new Driver(); //2. 得到连接 //(1) jdbc:mysql://，协议，规定好的，固定的，表示通过jdbc的方式连接mysql //(2) localhost，ip地址 //(3) 3306，mysql监听的端口号 //(4) jdbc_learning，连接的数据库的名称 //(5) mysql 的连接本质就是socket连接 String url = &quot;jdbc:mysql://localhost:3306/jdbc_learning&quot;; //将用户名和密码放入Properties对象中 //第一个参数 user 和 password 是规定好的，后面的值根据实际情况写 Properties properties = new Properties(); properties.setProperty(&quot;user&quot;, &quot;root&quot;);//用户名 properties.setProperty(&quot;password&quot;, &quot;zyl&quot;);//密码 Connection connect = driver.connect(url, properties); //3. 执行sql// String sql = &quot;insert into actor values(null, &#x27;刘德华&#x27;, &#x27;男&#x27;, &#x27;1970-11-11&#x27;, &#x27;110&#x27;)&quot;; String sql = &quot;update actor set name = &#x27;周星驰&#x27; where id = 1&quot;; //得到statement，执行静态SQL语句，并返回其生成的结果对象 Statement statement = connect.createStatement(); int rows = statement.executeUpdate(sql);//如果是dml语句，返回受影响的行数 System.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;); //4. 关闭连接 statement.close(); connect.close(); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Servlet p2 Servlet的生命周期","slug":"Servlet-p2-Servlet的生命周期","date":"2023-06-12T14:37:07.000Z","updated":"2023-06-12T14:47:23.837Z","comments":true,"path":"d9d03704.html","link":"","permalink":"http://example.com/d9d03704.html","excerpt":"","text":"学习课程： 【这可能是B站讲的最好的Servlet教程，5小时打通Servlet全套教程丨2022最新版，轻松掌握servlet基础+案例实操】 https://www.bilibili.com/video/BV1Kr4y1V7ZE/?share_source=copy_web&amp;vd_source=2c07d62293f5003c919b2df9b2e0549e Servlet的生命周期基本介绍​ Servleti没有main()方法，不能独立运行，它的运行完全由Servlet引擎来控制和调度。所谓生命周期，指的是servlet容器何时创建servlet实例、何时调用其方法进行请求的处理、何时并销毁其实例的整个过程。 实例和初始化时机 Servlet 通过调用 init () 方法进行初始化。当请求到达容器时，容器查找该servlet对象是否存在，如果不存在，则会创建实例并进行初始化。 就绪/调用/服务阶段Servlet 调用 service() 方法来处理客户端的请求。有请求到达容器，容器调用servlet对象的service()方法。处理请求的方法在整个生命周期中可以被多次调用；HttpServlet的service()方法，会依据请求方式来调用doGet0或者doPost()方法。但是，这两个do方法默认情况下，会抛出异常，需要子类去override。 销毁时机Servlet 通过调用 destroy() 方法终止（结束）。当容器关闭时（应用程序停止时），会将程序中的Servlet实例进行销毁。最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 上述的生命周期可以通过Servlet中的生命周期方法来观察。在Servlet中有三个生命周期方法，不由用户手动调用，而是在特定的时机有容器自动调用，观察这三个生命周期方法即可观察到Servlet的生命周期。 方法介绍 init方法：在Servlet实例创建之后执行（证明该Servlet有实例创建了）。init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。 ​ Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。 ​ 当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。 init 方法的定义如下： 12public void init() throws ServletException &#123; // 初始化代码...&#125; service方法：每次有请求到达某个Servlet方法时执行，用来处理请求（证明该Servlet进行服务了）。service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。 每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。 下面是该方法的特征： 1234public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException&#123;&#125; destroy方法：Servlet实例销毁时执行（证明该Servlet的实例被销毁了）。destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。 在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示： 123public void destroy() &#123; // 终止化代码... &#125; Servlet的生命周期，简单的慨括这就分为四步：servlet类加载-&gt;实例化-&gt;服务-&gt;销毁。下面我们描述一下Tomcat与Servlet是如何工作的，看看下面的时序图： Web Client向Servlet容器(Tomcat)发出Http请求 Servlet容器接收Web Client的请求 Servlet容器创建一个HttpServletRequest对象，将Web Client请求的信息封装到这个对象中 Servlet容器创建一个HttpServletResponse对象 Servlet容器调HttpServlet对象service方法，把Request与Response作为参数，传给HttpServlet HttpServlet调用HttpServletRequest对象的有关方法，获取Http请求信息 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.xxxx.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/ser05&quot;)public class servlet05 extends HttpServlet &#123; /** * 就绪/服务方法（处理请求数据） * 系统方法，服务器自动调用， * 当有请求到达Servlet时，就会调用该方法 * 方法可以被多次调用 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Servlet被调用...&quot;); &#125; /** * 初始化方法 * 系统方法，服务器自动调用，它在第一次创建 Servlet对象 时被调用 * 当请求到达Servlet容器时，Servlet容器会判断该Servlet对象是否存在，如果不存在，则创建实例，并调用该方法初始化 * 该方法在生命周期中只会执行一次 * @throws ServletException */ @Override public void init() throws ServletException &#123; System.out.println(&quot;Servlet被创建了，初始化...&quot;); &#125; /** * 销毁方法 * 系统方法，服务器自动调用，在 Servlet 生命周期结束时被调用 * 当服务器关闭或应用程序停止时，调用该方法 * 方法在生命周期中只会调用一次 */ @Override public void destroy() &#123; System.out.println(&quot;Servlet被销毁了...&quot;); &#125;&#125;","categories":[{"name":"B站Servlet教程","slug":"B站Servlet教程","permalink":"http://example.com/categories/B%E7%AB%99Servlet%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}]},{"title":"Servlet p1 Servlet的实现","slug":"Servlet-p1-Servlet的实现","date":"2023-06-12T14:36:54.000Z","updated":"2023-06-12T14:47:23.835Z","comments":true,"path":"1bd3216f.html","link":"","permalink":"http://example.com/1bd3216f.html","excerpt":"","text":"学习课程： 【这可能是B站讲的最好的Servlet教程，5小时打通Servlet全套教程丨2022最新版，轻松掌握servlet基础+案例实操】 https://www.bilibili.com/video/BV1Kr4y1V7ZE/?share_source=copy_web&amp;vd_source=2c07d62293f5003c919b2df9b2e0549e Servlet的实现基本介绍​ Servlet是Server与Applet的缩写，是服务端小程序的总思。使用Java语言编写的服务器端程序，可以像生成动态的WEB页，Servlet主要运行在服务器端，并由服务器调用执行，是一种按照Servlet标准来开发的类。是SUN公司提供的一门用于开发动态Web资源的技术。（言外之意：要实现web开发，需要实现Servlet标准) ​ 它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 ​ Servlet本质上也是Java类，但要遵循Servlet规范进行编写，没有main()方法，它的创建、使用、销毁都由Servlet容器进行管理（如Tomcat)。(言外之意：写自己的类，不用写main方法，别人自动调用） ​ Servlet是和HTTP协议是紧密联系的，其可以处理HTTP协议相关的所有内容。这也是Servlet应用广泛的原因之一。提供了Servlet功能的服务器，叫做Servlet容器，其常见容器有很多，如Tomcat，Jetty，WebLogic，Server，WebSphere，JBoss等等。 Servlet架构： 实现Servlet规范​ 实现 Servlet 规范，即继承 HttpServlet 类，需要导入相应的包，（在此之前需要导入对应的servlet的jar包）。该类中已经完成了通信的规则，我们只需要进行业务的实现即可。 1234import javax.servlet.http.HttpServlet;public class servlet01 extends HttpServlet&#123;&#125; 重写service方法和设置注解 重写service方法 ​ 满足Servlet规范只是让我们的类能够满足接收请求的要求，接收到请求后需要对请求进行分析，以及进行业务逻辑处理，计算出结果，则需要添加代码，在Servlet中有一个叫做service的方法，专门用来做请求处理的操作，业务代码则可以写在该方法中。 ​ service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。 ​ 每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。 设置注解 ​ 在完成好了一切代码的编写后，还需要向服务器说明，特定请求对应特定资源。 ​ 开发servletI项目，使用@WebServlet将一个继承于javax.servlet.http,HttpServlet的类定义为Servlet组件。在Servlet3.0中，可以使用@VebServleti注解将一个继承于javax.servlet.http.HttpServlet的类标注为可以处理用户请求的Servlet。 12345678910111213141516171819202122package com.xxxx.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;//@WebServlet(&quot;/ser01&quot;)//@WebServlet(name = &quot;Servlet01&quot;, value = &quot;/ser01&quot;)//name就是一个名字可写可不写，value后面可以接数组，数组中的地址都可以访问到该页面//@WebServlet(name = &quot;Servlet01&quot;, value = &#123;&quot;/ser01&quot;, &quot;/ser001&quot;&#125;)@WebServlet(&quot;/ser01&quot;)//路径中的 &quot;/&quot; 一定不能忘public class Servlet01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Hello Servlet!&quot;); resp.getWriter().write(&quot;Hello Servlet!&quot;); &#125;&#125; 实现Servlet的方式 继承HttpServlet类 继承GenericServlet类：GenericServlet类是HttpServlet类的父类，所以也可以用来实现Servlet； 实现Servlet接口：GenericServlet类也实现了Servlet接口，实现Servlet接口也可以使用Servlet； 以上三种方式通常使用HttpServlet，方法也更全面； 继承GenericServlet类： 12345678910111213141516package com.xxxx.servlet;import javax.servlet.GenericServlet;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;import java.io.IOException;@WebServlet(&quot;/ser02&quot;)public class servlet02 extends GenericServlet &#123; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;继承GenericServlet类...&quot;);//GenericServlet是HttpServlet的父类 &#125;&#125; 实现Servlet接口： 12345678910111213141516171819202122232425262728293031323334package com.xxxx.servlet;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException;@WebServlet(&quot;/ser03&quot;)public class servlet03 implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;实现Servlet接口&quot;);//GenericServlet实现了该接口 &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125;","categories":[{"name":"B站Servlet教程","slug":"B站Servlet教程","permalink":"http://example.com/categories/B%E7%AB%99Servlet%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}]},{"title":"JavaWeb p2 BS和CS","slug":"JavaWeb-p2-BS和CS","date":"2023-06-09T08:33:26.000Z","updated":"2023-06-09T08:34:17.738Z","comments":true,"path":"3f9f5936.html","link":"","permalink":"http://example.com/3f9f5936.html","excerpt":"","text":"BS和CS CS：客户端服务器架构模式 优点：充分利用客户端机器的资源，减轻服务器的负荷（一部分安全要求不高的计算任务存储任务放在客户端执行，从而能够减轻服务器的压力，也能够减轻网络负荷）； 缺点：需要安装；升级维护成本较高； BS：浏览器服务器架构模式 优点：客户端不需要安装；维护成本较低； 缺点：所有的计算和存储任务都是放在服务器端的，服务器的负荷较重；在服务端计算完成之后吧结果在传输给客户端，因此客户端和服务器端都会进行非常频繁的数据通信，从而网络负荷较重；","categories":[{"name":"B站尚硅谷JavaWeb学习笔记","slug":"B站尚硅谷JavaWeb学习笔记","permalink":"http://example.com/categories/B%E7%AB%99%E5%B0%9A%E7%A1%85%E8%B0%B7JavaWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}]},{"title":"JavaWeb p1 JS语法","slug":"JavaWeb-p1-JS语法","date":"2023-06-07T09:13:57.000Z","updated":"2023-06-09T08:31:10.530Z","comments":true,"path":"8e366b99.html","link":"","permalink":"http://example.com/8e366b99.html","excerpt":"","text":"JS语法学习Javascript：客户端的脚本语言 JavaScript数据类型 变量定义var a = 10; let b = 20; JS是一门动态的弱类型语言，变量的数据类型由后面赋的值决定，当操作涉及不匹配的类型是否，它将允许隐式类型转换，而不是抛出一个错误。 引用一下MDN的解释： 动态和弱类型JavaScript 是一种有着动态类型的动态语言。JavaScript 中的变量与任何特定值类型没有任何关联，并且任何变量都可以分配（重新分配）所有类型的值： 123let foo = 42; // foo 现在是一个数值foo = &quot;bar&quot;; // foo 现在是一个字符串foo = true; // foo 现在是一个布尔值 JavaScript 也是一个弱类型语言，这意味着当操作涉及不匹配的类型是否，它将允许隐式类型转换，而不是抛出一个错误。 123const foo = 42; // foo is a numberconst result = foo + &quot;1&quot;; // JavaScript coerces foo to a string, so it can be concatenated with the other operandconsole.log(result); // 421 强制隐式转换是非常方便的，但是如果开发者不打算转换，或者打算向另一个方向转换（例如，字符串转数值而不是数值到字符串），则会存在潜在的隐患。对于 symbol 和 BigInt，JavaScript 总是不允许某些隐式类型转换。 函数java方法定义： 12345public String hello(String name)&#123;return &quot;hello to&quot; + name;&#125; JS方法：若执行到return语句，就有返回值，没有执行到就没有返回值，到底有没有返回值，不确定，传入什么类型不确定，传入的参数的类型和数量无限制，随便传入。 123456789101112131415161718function hello(num1, num2, name)&#123; if(num1 &gt; num2)&#123; return &quot;hello to&quot; + name; &#125;else&#123; alert(&quot;HELLO&quot;); &#125;&#125;hello();hello(1);hello(1,1,&quot;abc&quot;);hello(1,2,3,4,&quot;abc&quot;); 代码演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;script language = &#x27;javascript&#x27;&gt; //String str = &quot;hello world&quot;; //java语法 var str = &quot;hello world&quot;; alert(typeof str);//string str = 9999 alert(typeof str);//number //JS中的alert，作用是在浏览器中弹出一个警告框。 //typeof 运算符返回一个字符串，表示操作数的类型 var person = new Object();//当前使用new创建了一个对象 person.pid = &quot;p001&quot;;//但是对象有什么属性不知道，你写了什么属性就有什么属性 person.name = &quot;大黄&quot;; alert(person.pid + &quot;_&quot; + person.name);//p001_大黄 /*java方法定义 public String hello(String name)&#123; return &quot;hello to&quot; + name; &#125; */ //js方法，若执行到return语句，就有返回值，没有执行到就没有返回值，到底有没有返回值，不确定 //传入什么类型不确定，传入的参数的类型和数量无限制，随便传入 function hello(num1, num2, name)&#123; if(num1 &gt; num2)&#123; return &quot;hello to&quot; + name; &#125;else&#123; alert(&quot;HELLO&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- Javascript：客户端的脚本语言 JS是一门弱类型语言，变量的数据类型由后面赋的值决定--&gt;","categories":[{"name":"B站尚硅谷JavaWeb学习笔记","slug":"B站尚硅谷JavaWeb学习笔记","permalink":"http://example.com/categories/B%E7%AB%99%E5%B0%9A%E7%A1%85%E8%B0%B7JavaWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}]},{"title":"反射 p5 反射相关使用和暴破","slug":"反射-p5-反射相关使用和暴破","date":"2023-06-05T13:31:46.000Z","updated":"2023-06-05T14:31:39.681Z","comments":true,"path":"b7fbfb20.html","link":"","permalink":"http://example.com/b7fbfb20.html","excerpt":"","text":"反射相关使用和暴破通过反射创建对象 方式一：调用类中的public修饰的无参构造器； 方式二：调用类中的指定构造器； Class类相关方法： newInstance()：调用类中的无参构造器，获取对应类的对象； getConstructor(Class…clazz)：根据参数列表，获取对应的public构造器对象； getDecalaredConstructor(Class…clazz)：根据参数列表，获取对应的所有构造器对象； Constructor类相关方法： setAccessible()：暴破； newInstance(Object…obj)：调用构造器； 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.hspedu.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * @author: 86199 * @date: 2023/6/5 20:32 * @description: 演示通过反射机制创建实例 */public class ReflectCreateInstance &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123; //先获取User类的Class对象 Class&lt;?&gt; userClass = Class.forName(&quot;com.hspedu.reflection.User&quot;); //1. 通过public无参构造器构造实例 Object user = userClass.newInstance(); System.out.println(&quot;user = &quot; + user); //2. 通过public有参构造器构造实例 /* 此时 constructor 对象就是这个构造器 public User(String name)&#123;//public 的有参构造器 this.name = name; &#125; */ //先得到对应的构造器 Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class); //创建实例，传入实参 Object user1 = constructor.newInstance(&quot;小花&quot;); System.out.println(&quot;user1 = &quot; + user1); //3. 通过非public有参构造器构造实例 //先得到对应的private构造器 Constructor&lt;?&gt; declaredConstructor = userClass.getDeclaredConstructor(String.class, int.class); //创建实例 declaredConstructor.setAccessible(true);//暴破【暴力破解】，使用反射可以访问private构造器/方法/属性，反射面前，都是纸老虎 Object user2 = declaredConstructor.newInstance(&quot;小黑&quot;, 20); System.out.println(&quot;user2 = &quot; + user2); &#125;&#125;class User&#123;//User类 //属性 private String name = &quot;大黄&quot;; private int age = 10; public User() &#123;//无参构造器 &#125; public User(String name)&#123;//public 的有参构造器 this.name = name; &#125; private User(String name, int age) &#123;//private 有参构造器 this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;User [ age = &quot; + age + &quot;, name = &quot; + name + &quot; ]&quot;; &#125;&#125;/*运行结果user = User [ age = 10, name = 大黄 ]user1 = User [ age = 10, name = 小花 ]user2 = User [ age = 20, name = 小黑 ]*/ 通过反射访问类中成员访问属性 根据属性名获取Field对象 Field f = clazz对象.getDeclaredField(属性名);//获取所有 Field f = clazz对象.getField(属性名);//获取公有 暴破：f.setAccessible(true)//f 是Field 访问 12f.set(o, 值) //o 表示本类的对象System.out.println(f.get(o));//o 表示对象 注意：如果是静态属性，则set和get中的参数o，可以写成null； 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.hspedu.reflection;import java.lang.reflect.Field;/** * @author: 86199 * @date: 2023/6/5 21:37 * @description: 演示反射操作属性 */public class ReflectAccessProperty &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123; //得到Student类对应的Class对象 Class&lt;?&gt; stuClass = Class.forName(&quot;com.hspedu.reflection.Student&quot;); //创建对象 Object o = stuClass.newInstance();//o 的运行类型就是Student System.out.println(o.getClass());//class com.hspedu.reflection.Student //1. 使用反射得到age属性对象 Field age = stuClass.getField(&quot;age&quot;);//拿到公有的 age.set(o, 88);//通过反射操作属性 System.out.println(o); System.out.println(age.get(o));//返回age的值 //2. 使用反射操作name属性 Field name = stuClass.getDeclaredField(&quot;name&quot;); name.setAccessible(true);//对name进行暴破，可以操作私有属性 //name.set(o, &quot;大黑&quot;); name.set(null, &quot;大白&quot;);//因为name是static修饰的，所以这里 o 也可以写成 null System.out.println(o); System.out.println(name.get(o));//获取属性值 System.out.println(name.get(null));//只有静态的才能这样用 &#125;&#125;class Student&#123;//类 public int age; private static String name; public Student() &#123; &#125; @Override public String toString() &#123; return &quot;Student [ &quot; + &quot;age = &quot; + age + &quot; name = &quot; + name + &#x27;]&#x27;; &#125;&#125;/* 运行结果class com.hspedu.reflection.StudentStudent [ age = 88 name = null]88Student [ age = 88 name = 大白]大白大白*/ 访问方法 根据方法名和参数列表获取Method方法对象： Method m = clazz.getDeclaredMethod(方法名, XX.class);//得到本类的所有方法 Method m = clazz.getMethod(方法名, XX.class);//得到本类的public方法 暴破：m.setAccessible(true); 访问：Object returnVal = m.invoke(o, 实参列表);//o就是本类的对象 注意：如果是静态方法，则invoke的参数o，可以写成null； 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.hspedu.reflection;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @author: 86199 * @date: 2023/6/5 21:56 * @description: 演示通过反射调用方法 */public class ReflectAccessMethod &#123; public static void main(String[] args) throws InstantiationException, IllegalAccessException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException &#123; //获取Boss类的Class对象 Class&lt;?&gt; bossCls = Class.forName(&quot;com.hspedu.reflection.Boss&quot;); //创建对象 Object o = bossCls.newInstance(); //1. 调用public 的 hi 方法 //得到hi方法对象// Method hi = bossCls.getMethod(&quot;hi&quot;, String.class);//OK Method hi = bossCls.getDeclaredMethod(&quot;hi&quot;, String.class);//OK hi.invoke(o, &quot;大黄！&quot;); //2. 调用private的say方法 //得到say方法对象 Method say = bossCls.getDeclaredMethod(&quot;say&quot;, int.class, String.class, char.class); //因为say方法私有，所以需要先暴破 say.setAccessible(true); System.out.println(say.invoke(o, 20, &quot;张三&quot;, &#x27;男&#x27;)); //3. 因为say方法是static，所以可以这样调用 System.out.println(say.invoke(null, 18, &quot;李四&quot;, &#x27;女&#x27;)); //返回值，在反射中如果方法有返回值统统返回Object，但是运行类型和方法定义的返回类型相同 //如果返回类型是void，返回null也是Object类型 Object reVal = say.invoke(null, 23, &quot;王五&quot;, &#x27;男&#x27;); System.out.println(&quot;reVal的运行类型&quot; + reVal.getClass()); &#125;&#125;class Boss&#123;//类 public int age; private static String name; public Boss() &#123;//构造器 &#125; private static String say(int n, String s, char c)&#123;//静态方法 return n + &quot; &quot; + s + &quot; &quot; + c; &#125; public void hi(String s)&#123;//普通方法 System.out.println(&quot;hi &quot; + s); &#125;&#125;/* 运行结果hi 大黄！20 张三 男18 李四 女reVal的运行类型class java.lang.String*/","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"反射 p4 反射获取类的结构信息","slug":"反射-p4-反射获取类的结构信息","date":"2023-06-04T09:10:52.000Z","updated":"2023-06-04T09:11:45.787Z","comments":true,"path":"69d36214.html","link":"","permalink":"http://example.com/69d36214.html","excerpt":"","text":"反射获取类的结构信息 关于Class的API getName：获取全类名 getSimpleName：获取简单类名 getFields：获取所有Public修饰的属性，包含本类及其父类（不仅仅是直接父类） getDeclaredFields：获取本类中的所有属性，不包括父类 getMethods：获取所有public修饰的方法，包含本类及其父类的（不仅仅是直接父类） getDeclaredMethods：获取本类中所有方法，不包括父类 getConstructors：获取所有public修饰的构造器，不包括父类 getDeclaredConstructors：获取本类中的所有构造器，不包括父类，构造器不能被继承 getPackage：以Package形式返回包信息 getSuperClass：以Class形式返回父类信息 getInterface：以Class[]形式返回接口信息，不包括父类 getAnnotations：以Annotation[]形式返回注解信息 关于Field的API getModifiers：以int的形式返回修饰符规定说明：默认修饰符是 0， public 是 1， protect 是 2， private 是 4 ， static 是 8， final 是 16 getType：以Class形式返回属性类型 getName：获得属性名 关于Method的API getModifiers：以int的形式返回修饰符规定说明：默认修饰符是 0， public 是 1， protect 是 2， private 是 4 ， static 是 8， final 是 16 getReturnType：以Class形式返回方法返回值类型 getName：获得方法名 getParameterTypes：以Class[]形式返回方法的形参列表 关于Constructor的API getModifiers：以int的形式返回修饰符规定说明：默认修饰符是 0， public 是 1， protect 是 2， private 是 4 ， static 是 8， final 是 16 getName：获得构造器名 getParameterTypes：以Class[]形式返回构造器的形参列表 案例演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204package com.hspedu.reflection;import org.junit.Test;import java.lang.annotation.Annotation;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * @author: 86199 * @date: 2023/6/4 10:42 * @description: 演示如何通过反射获取类的结构信息 */public class ReflectionUtils &#123; public static void main(String[] args) throws ClassNotFoundException &#123; ReflectionUtils reflectionUtils = new ReflectionUtils(); System.out.println(&quot;========================api_01()=======================&quot;); reflectionUtils.api_01(); System.out.println(&quot;========================api_02()=======================&quot;); reflectionUtils.api_02(); &#125; //第一组方法API：java.lang.Class @Test public void api_01() throws ClassNotFoundException &#123; //得到Class对象 Class&lt;?&gt; personCls = Class.forName(&quot;com.hspedu.reflection.Person&quot;); //1. getName：获取全类名 System.out.println(personCls.getName());//com.hspedu.reflection.Person //2. getSimpleName：获取简单类名 System.out.println(personCls.getSimpleName());//Person //3. getFields：获取所有Public修饰的属性，包含本类及其父类（不仅仅是直接父类） for (Field field : personCls.getFields()) &#123; System.out.println(&quot;本类及父类的公有属性&quot;+ field.getName()); &#125; //4. getDeclaredFields：获取本类中的所有属性，不包括父类 for (Field declaredField : personCls.getDeclaredFields()) &#123; System.out.println(&quot;本类中所有属性&quot; + declaredField.getName()); &#125; //5. getMethods：获取所有public修饰的方法，包含本类及其父类的（不仅仅是直接父类） for (Method method : personCls.getMethods()) &#123; System.out.println(&quot;本类及其父类的公有方法 = &quot; + method); &#125; //6. getDeclaredMethods：获取本类中所有方法，不包括父类 for (Method declaredMethod : personCls.getDeclaredMethods()) &#123; System.out.println(&quot;本类的方法 = &quot; + declaredMethod); &#125; //7. getConstructors：获取所有public修饰的构造器，不包括父类 for (Constructor&lt;?&gt; constructor : personCls.getConstructors()) &#123; System.out.println(&quot;本类的public构造器 = &quot; + constructor); &#125; //8. getDeclaredConstructors：获取本类中的所有构造器，不包括父类，构造器不能被继承 for (Constructor&lt;?&gt; declaredConstructor : personCls.getDeclaredConstructors()) &#123; System.out.println(&quot;本类的所有构造器 = &quot; + declaredConstructor); &#125; //9. getPackage：以Package形式返回包信息 System.out.println(personCls.getPackage());//package com.hspedu.reflection //10. getSuperClass：以Class形式返回父类信息 System.out.println(&quot;父类的class对象 = &quot; + personCls.getSuperclass());//父类的class对象 = class com.hspedu.reflection.A //11. getInterface：以Class[]形式返回接口信息，不包括父类 for (Class&lt;?&gt; anInterface : personCls.getInterfaces()) &#123; System.out.println(&quot;接口信息 = &quot; + anInterface); &#125; //12.getAnnotations：以Annotation[]形式返回注解信息 for (Annotation annotation : personCls.getAnnotations()) &#123; System.out.println(&quot;注解信息 = &quot; + annotation); &#125; &#125; //第二组方法API：java.lang.reflect.Filed，java.lang.reflect.Method @Test public void api_02() throws ClassNotFoundException &#123; //得到Class对象 Class&lt;?&gt; personCls = Class.forName(&quot;com.hspedu.reflection.Person&quot;); //1. getModifiers()：以int的形式返回修饰符 //规定说明：默认修饰符是 0， public 是 1， protect 是 2， private 是 4 ， static 是 8， final 是 16 //2. getType：以Class形式返回属性类型 //3. getName：获得属性名 for (Field declaredField : personCls.getDeclaredFields()) &#123;//获得Field[] System.out.println(&quot;本类中所有属性 &quot; + declaredField.getName() + &quot; 属性的修饰符值 &quot; + declaredField.getModifiers() + &quot;该属性的类型 &quot; + declaredField.getType()); &#125; //1. getModifiers()：以int的形式返回修饰符 //规定说明：默认修饰符是 0， public 是 1， protect 是 2， private 是 4 ， static 是 8， final 是 16 //2. getReturnType：以Class形式返回方法返回值类型 //3. getName：获得方法名 //4. getParameterTypes：以Class[]形式返回方法的形参列表 for (Method declaredMethod : personCls.getDeclaredMethods()) &#123;//获得Method[] System.out.print(&quot;本类的方法 = &quot; + declaredMethod.getName() + &quot; 方法的修饰符值 &quot; + declaredMethod.getModifiers() + &quot;该方法返回值的类型 &quot; + declaredMethod.getReturnType() + &quot; 方法的参数 &quot;); //输出方法的形参数组 for (Class&lt;?&gt; parameterType : declaredMethod.getParameterTypes()) &#123; System.out.print(parameterType + &quot; &quot;); &#125; System.out.println(); &#125; //1. getModifiers()：以int的形式返回修饰符 //规定说明：默认修饰符是 0， public 是 1， protect 是 2， private 是 4 ， static 是 8， final 是 16 //2. getName：获得构造器名 //4. getParameterTypes：以Class[]形式返回构造器的形参列表 for (Constructor&lt;?&gt; constructor : personCls.getDeclaredConstructors()) &#123;//获取Constructor[] System.out.print(&quot;本类的public构造器 = &quot; + constructor.getName()); for (Class&lt;?&gt; parameterType : constructor.getParameterTypes()) &#123; System.out.print(&quot; 该构造器的形参类型&quot; + parameterType + &quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125;class A&#123; public String hobby; public A() &#123; &#125; public void hi()&#123;&#125;&#125;interface IA&#123;&#125;interface IB&#123;&#125;@Deprecatedclass Person extends A implements IA,IB&#123; //属性 public String name; String job; protected int age; private double sal; //构造器 public Person() &#123; &#125; private Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person(String name) &#123; this.name = name; &#125; //方法 public void m1(String name, int age, double sal)&#123;&#125; protected String m2()&#123; return null; &#125; void m3()&#123;&#125; private void m4()&#123;&#125;&#125;/* 运行结果========================api_01()=======================com.hspedu.reflection.PersonPerson本类及父类的公有属性name本类及父类的公有属性hobby本类中所有属性name本类中所有属性job本类中所有属性age本类中所有属性sal本类及其父类的公有方法 = public void com.hspedu.reflection.Person.m1(java.lang.String,int,double)本类及其父类的公有方法 = public void com.hspedu.reflection.A.hi()本类及其父类的公有方法 = public final void java.lang.Object.wait() throws java.lang.InterruptedException本类及其父类的公有方法 = public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException本类及其父类的公有方法 = public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException本类及其父类的公有方法 = public boolean java.lang.Object.equals(java.lang.Object)本类及其父类的公有方法 = public java.lang.String java.lang.Object.toString()本类及其父类的公有方法 = public native int java.lang.Object.hashCode()本类及其父类的公有方法 = public final native java.lang.Class java.lang.Object.getClass()本类及其父类的公有方法 = public final native void java.lang.Object.notify()本类及其父类的公有方法 = public final native void java.lang.Object.notifyAll()本类的方法 = void com.hspedu.reflection.Person.m3()本类的方法 = private void com.hspedu.reflection.Person.m4()本类的方法 = protected java.lang.String com.hspedu.reflection.Person.m2()本类的方法 = public void com.hspedu.reflection.Person.m1(java.lang.String,int,double)本类的public构造器 = public com.hspedu.reflection.Person(java.lang.String)本类的public构造器 = public com.hspedu.reflection.Person()本类的所有构造器 = public com.hspedu.reflection.Person(java.lang.String)本类的所有构造器 = private com.hspedu.reflection.Person(java.lang.String,int)本类的所有构造器 = public com.hspedu.reflection.Person()package com.hspedu.reflection父类的class对象 = class com.hspedu.reflection.A接口信息 = interface com.hspedu.reflection.IA接口信息 = interface com.hspedu.reflection.IB注解信息 = @java.lang.Deprecated()========================api_02()=======================本类中所有属性 name 属性的修饰符值 1该属性的类型 class java.lang.String本类中所有属性 job 属性的修饰符值 0该属性的类型 class java.lang.String本类中所有属性 age 属性的修饰符值 4该属性的类型 int本类中所有属性 sal 属性的修饰符值 2该属性的类型 double本类的方法 = m3 方法的修饰符值 0该方法返回值的类型 void 方法的参数 本类的方法 = m4 方法的修饰符值 2该方法返回值的类型 void 方法的参数 本类的方法 = m2 方法的修饰符值 4该方法返回值的类型 class java.lang.String 方法的参数 本类的方法 = m1 方法的修饰符值 1该方法返回值的类型 void 方法的参数 class java.lang.String int double 本类的public构造器 = com.hspedu.reflection.Person 该构造器的形参类型class java.lang.String 本类的public构造器 = com.hspedu.reflection.Person 该构造器的形参类型class java.lang.String 该构造器的形参类型int 本类的public构造器 = com.hspedu.reflection.Person*/","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"反射 p3 类加载","slug":"反射-p3-类加载","date":"2023-05-23T08:58:50.000Z","updated":"2023-06-04T02:44:28.235Z","comments":true,"path":"5e45c00a.html","link":"","permalink":"http://example.com/5e45c00a.html","excerpt":"","text":"类加载基本说明反射机制是Java实现动态语言的关键，也就是通过反射实现类动态加载。 静态加载：编译时加载相关的类，如果没有则报错，依赖性太强。 动态加载：运行时加载相关的类，如果运行时不用该类，即使不存在该类，也不会报错，降低了依赖性。 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.util.*;import java.lang.reflect.*;public class ClassLoad_&#123; public static void main(String[] args) throws Exception&#123; Scanner scan = new Scanner(System.in); String key = scan.next(); switch(key)&#123; case &quot;1&quot;: Dog dog = new Dog();//静态加载，依赖性很强 dog.cry(); break; case &quot;2&quot;: //反射 -&gt; 动态加载 Class cls = Class.forName(&quot;Person&quot;);//加载Person类[动态加载] Object o = cls.newInstance(); Method m = cls.getMethod(&quot;hi&quot;); m.invoke(o); System.out.println(&quot;OK&quot;); break; default: System.out.println(&quot;do nothing....&quot;); &#125; &#125;&#125;/* 未写Dog类时，DOS窗口运行结果，编译错误C:\\Users\\86199\\Desktop&gt;javac ClassLoad_.javaClassLoad_.java:11: 错误: 找不到符号 Dog dog = new Dog();//静态加载，依赖性很强 ^ 符号: 类 Dog 位置: 类 ClassLoad_ClassLoad_.java:11: 错误: 找不到符号 Dog dog = new Dog();//静态加载，依赖性很强 ^ 符号: 类 Dog 位置: 类 ClassLoad_注: ClassLoad_.java使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。2 个错误*///因为 new Dog() 是静态加载，因此必须编写Dog类，否则在编译过程就会报错//Person类是动态加载，所以没有编写Person类在编译过程也不会报错，//只有在动态加载该类时才会报错class Dog&#123; public void cry()&#123; System.out.println(&quot;小狗汪汪叫&quot;); &#125;&#125;/* 未写Person类时，DOS窗口运行结果，运行时报错C:\\Users\\86199\\Desktop&gt;java ClassLoad_1小狗汪汪叫===============================================================C:\\Users\\86199\\Desktop&gt;java ClassLoad_2Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: Person at java.net.URLClassLoader.findClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Unknown Source) at ClassLoad_.main(ClassLoad_.java:16)*/class Person&#123; public void hi()&#123; System.out.println(&quot;hi....&quot;); &#125;&#125;/* 写了Peson类后，DOS窗口运行结果C:\\Users\\86199\\Desktop&gt;java ClassLoad_1小狗汪汪叫=================================================C:\\Users\\86199\\Desktop&gt;java ClassLoad_2hi....OK*/ 类加载时机 当创建对象时（new），静态加载； 当子类被加载时，父类也加载，静态加载； 调用类中的静态成员时，静态加载； 通过反射，动态加载； 类加载流程类加载流程图 类加载过程图 类加载各阶段完成的任务 类加载五个阶段 加载阶段（Loading） JVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络）==转化为二进制字节流加载到内存中==，并生成一个代表该类的java.lang.Class对象； 连接阶段（Linking） 验证（Verification）： 目的：是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全； 包括：文件格式验证（是否以魔数 oxcafebabe 开头）、元数据验证、字节码验证和符号引用验证； 可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机加载的时间； 准备（Preparation）： JVM 会在该阶段对静态变量，分配内存并默认初始化（对应数据类型的默认初始值，如0、0L、null、false等）。这些变量所使用的内存都将在方法区中进行分配。 1234567891011121314151617181920package com.hspedu.classload_;/** * @author: 86199 * @date: 2023/6/2 21:19 * @description: 说明类加载夹的连接阶段（Linking）-准备（Preparation） */public class ClassLoad02 &#123;&#125;class A&#123; //属性-字段-成员变量 //分析类加载阶段的连接阶段（Linking）-准备，属性是如何处理的 //1. n1是实例属性，不是静态变量，因此在准备阶段是不会分配内存的 //2. n2是静态属性，分配内存，n2 默认初始化为0，而不是20，20是在连接阶段之后的初始化阶段进行的 //3. n3是static final 是常量 public int n1 = 1; public static int n2 = 2; public final static int n3 = 3;&#125; 解析（Resolution）：虚拟机将常量池内的符号引用替换为直接引用的过程。 初始化（Initialization）： 到初始化阶段，才是真正的开始执行类中定义的Java程序代码，此阶段是执行()方法的过程； ()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有==静态变量==的赋值动作和==静态代码块==中的语句，并进行合并； 虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕； 源码： 案例演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.hspedu.classload_;/** * @author: 86199 * @date: 2023/6/2 22:19 * @description: 演示类加载——初始化阶段（Initialization） */public class ClassLoad03_ &#123; static &#123; System.out.println(&quot;ClassLoad03_ 静态代码块被执行&quot;); &#125; public static void main(String[] args) throws ClassNotFoundException &#123; //1. Loading：加载B类，并生成B类的Class对象 //2. Linking：num = 0 //3. Initialization： // 依次收集类中所有的静态变量和静态代码块中的语句入clinit()中，并合并 /* clinit()&#123; System.out.println(&quot;B 静态代码块被执行&quot;); //num = 300; num = 100; &#125; 合并：num = 300, num = 100 --&gt; num = 100 */// new B();//也会使B类加载，但是B类加载只会执行一遍// System.out.println(B.num);//直接使用B类的静态属性，也会导致B类加载 //看看类加载时，是有同步机制控制的 /* protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; //拿到一个同步锁，正因为有这个机制，才能保证某个类在内存中只有一份Class对象 &#125; &#125; */ Class&lt;?&gt; aClass = Class.forName(&quot;B&quot;); &#125;&#125;class B&#123; static &#123; System.out.println(&quot;B 静态代码块被执行&quot;); num = 300; &#125; static int num = 100; public B() &#123;//构造器 System.out.println(&quot;B() 构造器被执行...&quot;); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"反射 p2 Class类","slug":"反射-p2-Class类","date":"2023-05-21T14:20:47.000Z","updated":"2023-05-23T08:55:35.052Z","comments":true,"path":"7ec0f897.html","link":"","permalink":"http://example.com/7ec0f897.html","excerpt":"","text":"Class类基本介绍 Class也是类，因此也继承Object类； Class类对象不是new出来的，而是系统创建的； 对于某个类的Class类对象，在内存中只有一份，因为类只加载一次； 每个类的实例都会记得自己是由哪个Class实例所生成的； 通过Class对象可以完整的得到一个类的完整结构，通过一系列API； Class对象是存放在堆中的； 类的字节码二进制数据，是存放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限等等）；【https://www.zhihu.com/question/38496907】 Class类的常用方法 方法名 功能说明 static Class forName(String name) 返回指定类名 name 的 Class对象 Object newInstance() 调用缺省构造函数，返回该Class对象的一个实例 getName() 返回此Class对象所表示的实体（类、接口、数组类、基本类型等）名称 Class[] getInterfaces() 获取当前CLass对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 Class gerSuperclass() 返回表示此Class所表示的实体的父类的Class ConStructor[] gerConstructors() 返回一个包含某些Constructor对象的数组 Field[] getDeclaredFields() 返回Field对象的一个数组 Method gerMethod(String name, Class … paramTypes) 返回一个Method对象，此对象的形参为paramType 代码演示 Car类： 12345678910111213141516171819202122package com.hspedu;/** * @author: 86199 * @date: 2023/5/22 10:27 * @description: */public class Car &#123; public String brand = &quot;宝马&quot;; public int price = 500000; public String color = &quot;白色&quot;; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;brand=&#x27;&quot; + brand + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &quot;, color=&#x27;&quot; + color + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; Class02： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.hspedu.class_;import com.hspedu.Car;import java.lang.reflect.Field;/** * @author: 86199 * @date: 2023/5/22 10:28 * @description: 演示Class类的常用方法 */public class Class02 &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123; String classAllPath = &quot;com.hspedu.Car&quot;; //1. 获取到Car类 对应的Class对象 //&lt;?&gt; 表示不确定java类型 Class&lt;?&gt; aClass = Class.forName(classAllPath); //2. 输出 aClass System.out.println(aClass);//显示 aClass 是哪个类的Class对象 com.hspedu.Car System.out.println(aClass.getClass());//输出 aClass 的运行类型 java.lang.Class //3. 得到包名 System.out.println(aClass.getPackage().getName());//com.hspedu //4. 得到全类名 System.out.println(aClass.getName());//com.hspedu.Car //5. 通过 aClass 生成对象实例 Car car = (Car) aClass.newInstance(); System.out.println(car); //6. 通过反射获取属性 brand Field brand = aClass.getField(&quot;brand&quot;); System.out.println(brand.get(car)); //7. 通过反射给字段赋值 brand.set(car, &quot;奔驰&quot;); System.out.println(brand.get(car)); //8. 得到所有的属性 Field[] fields = aClass.getFields(); for (Field field: fields) &#123; System.out.println(field.get(car)); &#125; &#125;&#125; 获取Class类对象 获取Class对象的6种方式： 前提：已知一个类的全类名，且该类在类路径下，可以通过Class类的静态方法 forName()获取，可能抛出ClassNotFoundException。实例：Class cls1 = Class.forName(&quot;java.lang.String&quot;); 应用场景：多用于配置文件，读取类全路径，加载类。 前提：若已知具体的类，同通过类的class获取，该方式最为安全可靠，程序性能也最高。实例：Class cls2 = Cat.class; 应用场景：多用于参数传递，比如通过反射得到对应构造器对象。 前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象。实例：Class cls3 = 对象.getClass();//运行类型，所以说查看运行类型就是获取该对象关联的Class对象，查看其代表的类型 应用场景：通过创建好的对象，获取Class对象。 其他方式：通过类加载器【4种】来获取到类的Class对象也就是说从一个类里获得类加载器可以用来加载出其他类 1234//（1）先得到类加载器ClassLoader classLoader = 对象.getClass().getClassLoader();//（2）通过类加载器得到Class对象Class cls4 = classLoader.loadClass(&quot;类的全类名&quot;); 弹幕摘要： 这种方法就是比第三种绕了一大圈； 从一个类里获得类加载器可以用来加载出其他类，这只是告诉你可以通过类加载器方式获得类对象，不是让你一定要这么做，只是告诉你有这种方式； 基本数据类型（int, char, boolean, float, double, byte, long, short） 按如下方式得到Class类对象 Class cls = 基本数据类型.class; 基本数据类型的包装类，可以通过.TYPE 得到Class类对象 Class cls = 包装类.TYPE 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.hspedu.class_;import com.hspedu.Car;/** * @author: 86199 * @date: 2023/5/22 11:13 * @description: 演示获取Class对象的各种方式 */public class GetClass_ &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //1. Class.forName String classAllPath = &quot;com.hspedu.Car&quot;;//通过读取配置文件获取 Class&lt;?&gt; cls1 = Class.forName(classAllPath); System.out.println(&quot;cls1 = &quot; + cls1); //2. 类名.class Class cls2 = Car.class; System.out.println(&quot;cls2 = &quot; + cls2); //3. 对象.getClass()，应用场景，有对象实例 Car car = new Car(); Class cls3 = car.getClass(); System.out.println(&quot;cls3 = &quot; + cls3); //4. 通过类加载器【4种】来获取到类的Class对象 //这种方法就是比第三种绕了一大圈，从一个类里获得类加载器可以用来加载出其他类 //这只是告诉你可以通过类加载器方式获得类对象，不是让你一定要这么做，只是告诉你有这种方式 //（1）先得到类加载器 ClassLoader classLoader = car.getClass().getClassLoader(); //（2）通过类加载器得到Class对象 Class cls4 = classLoader.loadClass(classAllPath); Class&lt;?&gt; aClass = classLoader.loadClass(&quot;java.lang.String&quot;); System.out.println(&quot;cls4 = &quot; + cls4); System.out.println(aClass); //cls1,cla2,cls3, cls4 都是同一个对象 System.out.println(cls1.hashCode()); System.out.println(cls2.hashCode()); System.out.println(cls3.hashCode()); System.out.println(cls4.hashCode()); //5. 基本数据类型（int, char, boolean, float, double, byte, long, short） 按如下方式得到Class类对象 Class&lt;Integer&gt; integerClass = int.class; Class&lt;Character&gt; characterClass = char.class; Class&lt;Boolean&gt; booleanClass = boolean.class; System.out.println(integerClass); //6. 基本数据类型的包装类，可以通过.TYPE 得到Class类对象 Class&lt;Integer&gt; type1 = Integer.TYPE; Class&lt;Character&gt; type2 = Character.TYPE; System.out.println(type1); System.out.println(integerClass.hashCode()); System.out.println(type1.hashCode()); &#125;&#125;/* 运行结果cls1 = class com.hspedu.Carcls2 = class com.hspedu.Carcls3 = class com.hspedu.Carcls4 = class com.hspedu.Carclass java.lang.String460141958460141958460141958460141958intint11631578841163157884*/ 哪些类型有Class对象 外部类，成员内部类，静态内部类，局部内部类，匿名内部类 Interface接口 数组 enum枚举 annotation注解 基本数据类型 void 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.hspedu.class_;import java.io.Serializable;/** * @author: 86199 * @date: 2023/5/23 16:42 * @description: */public class AllTypeClass &#123; public static void main(String[] args) &#123; Class&lt;String&gt; cls1 = String.class;//外部类 Class&lt;Serializable&gt; cls2 = Serializable.class;//接口 Class&lt;float[]&gt; cls3 = float[].class;//数组 Class&lt;float[][]&gt; cls4 = float[][].class;//二维数组 Class&lt;Thread.State&gt; cls5 = Thread.State.class;//枚举 Class&lt;Deprecated&gt; cls6 = Deprecated.class;//注解 Class&lt;Long&gt; cls7 = long.class;//基本数据类型 Class&lt;Void&gt; cls8 = void.class;//void Class&lt;Class&gt; cls9 = Class.class;//Class类 System.out.println(cls1); System.out.println(cls2); System.out.println(cls3); System.out.println(cls4); System.out.println(cls5); System.out.println(cls6); System.out.println(cls7); System.out.println(cls8); System.out.println(cls9); &#125;&#125;/* 运行结果class java.lang.Stringinterface java.io.Serializableclass [Fclass [[Fclass java.lang.Thread$Stateinterface java.lang.Deprecatedlongvoidclass java.lang.Class*/","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"反射 p1 反射机制","slug":"反射-p1-反射机制","date":"2023-05-18T02:04:26.000Z","updated":"2023-05-23T08:54:01.870Z","comments":true,"path":"27cced6a.html","link":"","permalink":"http://example.com/27cced6a.html","excerpt":"","text":"反射机制引出反射 这样的需求在学习框架时特别多，即通过外部文件配置，在不修改源码的情况下，来控制程序，也符合设计模式的OCP原则（开闭原则：不修改源码，扩展功能）。 代码演示： re.properties文件： 12classfullpath=com.hspedu.Catmethod=cry Cat类： 12345678910111213141516171819202122232425package com.hspedu;/** * @author: 86199 * @date: 2023/5/18 10:09 * @description: */public class Cat &#123; private Strinag name = &quot;招财猫&quot;; public int age = 10; public Cat() &#123; &#125; public Cat(String name) &#123; this.name = name; &#125; public void hi()&#123; System.out.println(&quot;hi&quot; + name); &#125; public void cry()&#123; System.out.println(name + &quot;喵喵叫&quot;); &#125;&#125; ReflectionQuestion： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.hspedu.reflection.question;import com.hspedu.Cat;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;/** * @author: 86199 * @date: 2023/5/18 10:14 * @description: */public class ReflectionQuestion &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123; //普通方式// Cat cat = new Cat();// cat.hi(); //IO流，使用Preperties类读写配置文件 Properties properties = new Properties(); properties.load( new FileReader(&quot;src\\\\com\\\\hspedu\\\\re.properties&quot;)); String classfullpath = properties.get(&quot;classfullpath&quot;).toString(); String methodName = properties.getProperty(&quot;method&quot;); System.out.println(classfullpath); System.out.println(methodName); //使用反射解决 //(1)加载类，返回Class类型的对象 cls Class cls = Class.forName(classfullpath); //(2)通过cls 得到你的加载的类 com.hspedu.Cat 的对象实例 Object o = cls.newInstance(); System.out.println(&quot;o 的运行类型 = &quot; + o.getClass());//运行类型 //(3)通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName&quot;hi&quot; 的方法对象 // 即：在反射中，可以把方法视为对象（万物皆对象） Method method = cls.getMethod(methodName); //(4) 通过method调用方法：即通过方法对象类实现调用方法 System.out.println(&quot;============================&quot;); method.invoke(o); //可以直接通过修改配置文件，而不是源码来改变调用的方法 &#125;&#125;/*运行结果：com.hspedu.Catcryo 的运行类型 = class com.hspedu.Cat============================招财猫喵喵叫*/ 反射机制 反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息（比如成员变量，构造器，成员方法等等），并能操作对象的属性及方法。反射在设计模式和框架底层都会用到； 加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以形象的称之为：反射。 在启动时，包含main方法的类被加载。它会加载所有需要的类。这些被加载的类又要加载它们需要的类，以此类推。 反射原理图 弹幕摘要： 加载的过程在方法区，加载结果（对象）在堆区，不知道对不对； 类加载是将数据放入的内存的方法区中，然后在堆创建一个class对象，说白了就是堆中的class是用来封装方法区数据的类 疑惑： 那为什么需要这样一个Class对象呢？ Class类的对象的作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要。 是这样的，当我们new一个新对象或者引用静态成员变量时，Java虚拟机(JVM)中的类加载器子系统会将对应Class对象加载到JVM中，然后JVM再根据这个类型信息相关的Class对象创建我们需要实例对象或者提供静态变量的引用值。也就是说，Class对象对于类的实例化具有非常重要的意义。没它就没法new新对象和引用静态成员变量。 ————————————————版权声明：本文为CSDN博主「一只野生饭卡丘」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/Searchin_R/article/details/84591735 反射相关的主要类 java.lang.Class：代表一个类，Class对象表示某个类加载后在堆中的对象； java.lang.reflect.Method：代表类的方法，Method对象表示某个类的方法； java.lang.reflect.Field：代表类的成员变量，Field对象表示某个类的成员变量； java.lang.reflect.Constructor：代表类的构造方法，Constructor对象表示构造器； 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.hspedu.reflection;import java.io.FileReader;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.Properties;/** * @author: 86199 * @date: 2023/5/20 10:52 * @description: */public class Reflection01 &#123; public static void main(String[] args) throws Exception&#123; //1. IO流，使用Preperties类读写配置文件 Properties properties = new Properties(); properties.load( new FileReader(&quot;src\\\\com\\\\hspedu\\\\re.properties&quot;)); String classfullpath = properties.get(&quot;classfullpath&quot;).toString(); String methodName = properties.getProperty(&quot;method&quot;); //2. 使用反射解决 //(1)加载类，返回Class类型的对象 cls Class cls = Class.forName(classfullpath); //(2)通过cls 得到你的加载的类 com.hspedu.Cat 的对象实例 Object o = cls.newInstance(); System.out.println(&quot;o 的运行类型 = &quot; + o.getClass());//运行类型 //(3)通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName&quot;hi&quot; 的方法对象 // 即：在反射中，可以把方法视为对象（万物皆对象） Method method = cls.getMethod(methodName); //(4) 通过method调用方法：即通过方法对象类实现调用方法 System.out.println(&quot;============================&quot;); method.invoke(o); //java.lang.reflect.Field：代表类的成员变量，Filed对象白哦是某个类的成员变量 //得到age字段 //getField不能得到私有属性 Field ageFiled = cls.getField(&quot;age&quot;); System.out.println(ageFiled.get(o)); //java.lang.reflect.Constructor：代表类的构造方法，Constructor对象表示构造器 Constructor constructor = cls.getConstructor();//()中可以指定构造器参数类型，不指定返回无参构造器 System.out.println(constructor);//Cat() Constructor constructor1 = cls.getConstructor(String.class);//传入String类的Class对象 System.out.println(constructor1);//Cat(java.lang.String) &#125;&#125; 反射的优缺点： 优点：可以动态的创建和使用对象（也是框架的底层核心），使用灵活，没有反射机制，框架技术就失去了底层支撑。 缺点：使用反射基本是解释执行，对执行速度有影响。 反射调用优化——关闭访问检查 Method和Field、Constructor对象都有setAccessible()方法； setAccessible()作用是启动和禁用访问安全检查的开关； 参数值为true表示反射的对象在使用时取消访问检查，可以提高反射的效率。参数值为false则表示反射的对象执行访问检查。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.hspedu.reflection;import com.hspedu.Cat;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @author: 86199 * @date: 2023/5/20 11:20 * @description: 测试反射调用的性能，和优化方案 */public class Reflection02 &#123; public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException &#123; m1(); m2(); m3(); &#125; //这里先把hi()方法中的打印注释了 //传统方法调用方法hi public static void m1()&#123; Cat cat = new Cat(); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 90000000; i++)&#123; cat.hi(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;m1() 耗时 = &quot; + (end - start)); &#125; //反射机制调用方法hi public static void m2() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123; Class cls = Class.forName(&quot;com.hspedu.Cat&quot;); Object o = cls.newInstance(); Method method = cls.getMethod(&quot;hi&quot;); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 90000000; i++)&#123; method.invoke(o); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;m2() 耗时 = &quot; + (end - start)); &#125; //反射优化：关闭访问检测 public static void m3() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123; Class cls = Class.forName(&quot;com.hspedu.Cat&quot;); Object o = cls.newInstance(); Method method = cls.getMethod(&quot;hi&quot;); method.setAccessible(true);//取消在访问调用方法时的访问检查 long start = System.currentTimeMillis(); for (int i = 0; i &lt; 90000000; i++)&#123; method.invoke(o); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;m3() 耗时 = &quot; + (end - start)); &#125;&#125;/*运行结果m1() 耗时 = 3m2() 耗时 = 197m3() 耗时 = 168*/","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"网络编程 p5 UDP编程","slug":"网络编程-p5-UDP编程","date":"2023-05-18T01:56:26.000Z","updated":"2023-05-18T14:35:38.980Z","comments":true,"path":"8ab10e56.html","link":"","permalink":"http://example.com/8ab10e56.html","excerpt":"","text":"UDP网络通信编程 基本介绍 类DatagramSocket和DatagramPacket实现了基于UDP协议网络程序。 UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。 DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。 UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接送方的连接。 基本流程 核心的两个类/对象 DatagramSocket/DatagramPacket 建立发送端，接收端 建立数据包 调用DatagramSocket的发送和接收方法 关闭DatagramSocket UDP网络编程原理示意图 注意事项 没有明确的服务端和客户端，演变成数据的发送端和接收端； 接收数据和发送数据是通过DatagramSocket对象完成的； 将数据封装到DatagramPacket对象/装包； 当接收到DatagramPacket对象，需要进行拆包，取出数据； DatagramSocket可以指定在哪个端口接收数据； 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.hspedu.udp;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;/** * @author: 86199 * @date: 2023/5/17 17:49 * @description: UDP */public class UDPReceiverA &#123; public static void main(String[] args) throws IOException &#123; //1. 创建一个DatagramSocket 对象，准备在9999接收数据 DatagramSocket socket = new DatagramSocket(9999); //2. 构建一个DatagramPacket对象，用来接收数据 // UDP，一个数据包最大64K byte[] bytes = new byte[1024]; DatagramPacket packet = new DatagramPacket(bytes, bytes.length); //3. 调用接受方法，将通过网络传输的 DatagramPacket 对象填充到packet对象 // 注意：当有数据发送到 本机的9999端口时，就会接收到数据 // 如果没有数据包发送到 本机的9999端口，就会阻塞等待 System.out.println(&quot;接收端A 等待接收数据……&quot;); socket.receive(packet); int length = packet.getLength(); byte[] data = packet.getData(); String s = new String(data, 0, length); System.out.println(s); //a端作发送端 byte[] data2 = &quot;好的，明天见&quot;.getBytes(); DatagramPacket packet1 = new DatagramPacket(data2, data2.length, InetAddress.getByName(&quot;10.15.205.153&quot;), 9998); socket.send(packet1); //关闭资源 socket.close(); System.out.println(&quot;A端退出...&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.hspedu.udp;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;/** * @author: 86199 * @date: 2023/5/17 17:50 * @description: UDP */public class UDPSenderB &#123; public static void main(String[] args) throws IOException &#123; //1. 创建 DatagramSocket 对象，准备在9998端口 发送数据 DatagramSocket socket = new DatagramSocket(9998); //2. 将需要发送的数据，封装到 DatagramPacket对象 byte[] data = &quot;hello，明天去吃火锅吧&quot;.getBytes(); //说明：封装 DatagramPacket对象 data 内容字节数组，data.length，主机（IP），端口 DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(&quot;10.15.205.153&quot;), 9999); socket.send(packet); //B端作接收端 byte[] bytes = new byte[1024]; DatagramPacket packet1 = new DatagramPacket(bytes, bytes.length); System.out.println(&quot;接收端B 等待接收数据……&quot;); socket.receive(packet1); int length = packet1.getLength(); byte[] data1 = packet1.getData(); String s = new String(data1, 0, length); System.out.println(s); //关闭资源 socket.close(); System.out.println(&quot;B端退出...&quot;); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"网络编程 p4 TCP编程","slug":"网络编程-p4-TCP编程","date":"2023-05-18T01:56:07.000Z","updated":"2023-05-18T14:35:38.977Z","comments":true,"path":"5681cccc.html","link":"","permalink":"http://example.com/5681cccc.html","excerpt":"","text":"TCP编程 基本介绍 基于客户端——服务端的网络通信； 底层使用的是TCP/IP协议； 应用场景举例：客户端发送数据，服务端接收并显示在控制台； 基于Socket的TCP编程； 示意图 netstat指令 netstat -an可以查看当前主机网络情况，包括端口监听情况和网络连接情况； netstat -an|more可以分页显示； 要求在dos控制台下执行 （win+r） 说明： Listening 表示某个端口在监听； 如果有一个外部程序（客户端）连接到该端口，就会显示一条连接信息； 应用案例 客户端 123456789101112131415161718192021222324252627282930313233343536373839package com.hspedu.socket;import java.io.*;import java.net.InetAddress;import java.net.Socket;/** * @author: 86199 * @date: 2023/5/15 15:18 * @description: 字符流 */public class SocketTCP03Client &#123; public static void main(String[] args) throws IOException &#123; //思路 //1. 连接服务端（ip，端口） //解读：连接本机的 9999 端口，如果连接成功，返回Socket对象 Socket socket = new Socket(InetAddress.getLocalHost(), 9999); System.out.println(&quot;客户端 socket返回 = &quot; + socket.getClass()); //2. 连接上后，生成Socket，通过socket.getOutputStream() // 得到和socket对象关联的输出流对象 BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); //3. 通过输出流，写入数据到 数据通道 bufferedWriter.write(&quot;hello, server&quot;); bufferedWriter.newLine();//写入一个换行符，表示写入内容结束，要求对方使用readLine的方式来读 bufferedWriter.flush();//如果使用的字符流，需要手动刷新否则数据不会写入数据通道 //4. 通过socket.个体InputStream()读取客户端写入到数据通道的数据，显示 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s = bufferedReader.readLine(); System.out.println(s); //5. 关闭流对象和socket，必须关闭 bufferedReader.close(); bufferedWriter.close(); socket.close(); &#125;&#125; 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.hspedu.socket;import java.io.*;import java.net.ServerSocket;import java.net.Socket;/** * @author: 86199 * @date: 2023/5/15 15:18 * @description: 字符流 */public class SocketTCP03Server &#123; public static void main(String[] args) throws IOException &#123; //思路 //1. 在本机的9999端口监听，等待连接 // 细节：要求本机没有其他服务在监听9999 // 这个 ServerSocket 可以通过accept() 返回多个Socket[多个客户端连接服务器的并发] ServerSocket serverSocket = new ServerSocket(9999); System.out.println(&quot;服务端，在9999端口监听，等待连接...&quot;); //2. 当没有客户端连接9999端口时程序会阻塞，等待连接 // 如果有客户端连接，则会返回Socket对象，程序继续 Socket accept = serverSocket.accept(); System.out.println(&quot;服务端 socket = &quot; + accept.getClass()); //3. 通过socket.个体InputStream()读取客户端写入到数据通道的数据，显示 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(accept.getInputStream()));//读不到内容会阻塞//4. IO读取 String s = bufferedReader.readLine(); System.out.println(s); //5. 通过输出流，写入数据到 数据通道 BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bufferedWriter.write(&quot;hello, client&quot;); bufferedWriter.newLine();//写入一个换行符，表示写入内容结束，要求对方使用readLine的方式来读 bufferedWriter.flush();//如果使用的字符流，需要手动刷新否则数据不会写入数据通道 //设置结束标记 //6. 关闭流对象和socket，必须关闭 bufferedWriter.close(); bufferedReader.close(); accept.close(); serverSocket.close(); &#125;&#125; StreamUtils类 123456789101112131415161718192021222324252627282930313233343536373839package com.hspedu.upload;import java.io.BufferedReader;import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.io.InputStreamReader;/** * @author: 86199 * @date: 2023/5/16 14:57 * @description: 工具类 */public class StreamUtils &#123; public static byte[] streamToByteArray(InputStream is) throws Exception &#123; // 创建输出流对象 ByteArrayOutputStream bos = new ByteArrayOutputStream(); // 字节数组 byte[] b = new byte[1024]; int len; while ((len = is.read(b)) != -1) &#123; // 循环读取 // 把读取到的数据，写入 bos bos.write(b, 0, len); &#125; byte[] array = bos.toByteArray(); bos.close(); return array; &#125; public static String streamToString(InputStream is) throws Exception &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(is)); StringBuilder builder = new StringBuilder(); String line; while ((line = reader.readLine()) != null) &#123; builder.append(line + &quot;\\r\\n&quot;); &#125; return builder.toString(); &#125;&#125; 服务端 123456789101112131415161718192021222324252627282930313233343536373839package com.hspedu.upload;import java.io.*;import java.net.ServerSocket;import java.net.Socket;/** * @author: 86199 * @date: 2023/5/15 16:24 * @description: */public class TCPFileUploadServer &#123; public static void main(String[] args) throws Exception &#123; ServerSocket serverSocket = new ServerSocket(8888); System.out.println(&quot;服务端在8888等待连接......&quot;); Socket accept = serverSocket.accept(); String filePath = &quot;D:\\\\program\\\\javaProject\\\\Idea_Java_Project\\\\chapter21\\\\src\\\\copy.jpg&quot;; BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath)); byte[] bytes = StreamUtils.streamToByteArray(bis); bos.write(bytes); bos.close(); //向客户端回复“收到图片” BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bufferedWriter.write(&quot;收到图片&quot;); bufferedWriter.flush(); accept.shutdownOutput(); //关闭流和socket bis.close(); accept.close(); serverSocket.close(); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031323334353637383940package com.hspedu.upload;import java.io.*;import java.net.InetAddress;import java.net.Socket;/** * @author: 86199 * @date: 2023/5/15 16:24 * @description: */public class TCPFileUploadClient &#123; public static void main(String[] args) throws Exception &#123; Socket socket = new Socket(InetAddress.getLocalHost(), 8888); String filePath = &quot;e:\\\\qie.jpg&quot;; BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath)); byte[] bytes = StreamUtils.streamToByteArray(bis); bos.write(bytes); bos.flush(); //没有手动调用flush方法，也没有调用close方法关闭流，数据复制失败， //因为数据还在内部缓冲区，并没有输出 (因为内部缓冲区没有被放满，不调用flush方法，不会输出） bis.close(); socket.shutdownOutput(); //接收消息 InputStream inputStream = socket.getInputStream(); String s = StreamUtils.streamToString(inputStream); System.out.println(s); //关闭流和socket inputStream.close(); bos.close(); socket.close(); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"网络编程 p3 Socket","slug":"网络编程-p3-Socket","date":"2023-05-18T01:55:50.000Z","updated":"2023-05-18T14:35:38.978Z","comments":true,"path":"b8241971.html","link":"","permalink":"http://example.com/b8241971.html","excerpt":"","text":"Socket 基本介绍 套接字（Socket）开发网络应用程序被广泛采用以至于成为事实上的标准； 通信的两端都要有Socket，是两台机器间通信的端点； 网络通信其实就是Socket间的通信； Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输； 一般主动发起通信的应用程序属客户端，等待通信我请求的为服务端； 示意图 弹幕摘要： 个人理解：Socket应该是负责数据的输入输出，两端必须都是Socket才能兼容。 但传出的数据还得走TCP/IP协议层层打包，到另一台主机上再层层解包，最后服务端的Socket接收数据。","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"网络编程 p2 InetAddress","slug":"网络编程-p2-InetAddress","date":"2023-05-18T01:55:34.000Z","updated":"2023-05-18T14:35:38.973Z","comments":true,"path":"82f73df4.html","link":"","permalink":"http://example.com/82f73df4.html","excerpt":"","text":"InetAddress类相关方法： getLocalHost()：获取本机InetAddress对象； getByName()：根据指定主机名/域名获取IP地址对象； getHostName()：获取Inet Address对象的主机名； **getHostAddress()**：获取InerAddress对象的地址； 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142import java.net.InetAddress;import java.net.UnknownHostException;/** * @author: 86199 * @date: 2023/5/14 16:19 * @description: 演示InetAddress类的使用 */public class API_ &#123; public static void main(String[] args) throws UnknownHostException &#123; //1. 获取本机的InetAddress对象 InetAddress localHost = InetAddress.getLocalHost(); System.out.println(&quot;localHost = &quot; + localHost); //2. 根据指定的主机名，获取 InetAddress对象 InetAddress host1 = InetAddress.getByName(&quot;LAPTOP-6CFCSNPH&quot;); System.out.println(&quot;host1 = &quot; + host1); //3. 根据域名返回 InetAddress对象 InetAddress host2 = InetAddress.getByName(&quot;www.baidu.com&quot;); System.out.println(&quot;host2 = &quot; + host2);//www.baidu.com/110.242.68.4 //4. 通过 InetAddress对象 获取地址 String hostAddress = host2.getHostAddress();//IP地址 System.out.println(&quot;host2的 ip = &quot; + hostAddress); //5. 通过 InetAddress对象 获取 主机名或域名 String hostName = host2.getHostName(); System.out.println(&quot;host2 对应的主机名/域名 = &quot; + hostName); &#125;&#125;/*运行结果：localHost = LAPTOP-6CFCSNPH/xx.xx.xx.xxhost1 = LAPTOP-6CFCSNPH/xx.xx.xx.xxhost2 = www.baidu.com/110.242.68.3host2的 ip = 110.242.68.3host2 对应的主机名/域名 = www.baidu.com*/","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"网络编程 p1 网络基础","slug":"网络编程-p1-网络基础","date":"2023-05-17T14:55:46.000Z","updated":"2023-05-18T14:35:38.975Z","comments":true,"path":"1ffd95bb.html","link":"","permalink":"http://example.com/1ffd95bb.html","excerpt":"","text":"网络基础网络通信 概念：两台设备之间通过网络实现数据传输； 网络通信：将数据通过网络从一台设备传输到另一台设备； java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信； 网络 概念：两台或多台设备通过一定物理设备连接起来构成了网络； 根据网络的覆盖范围不同，对网络进行分类： 局域网：覆盖范围最小，仅仅覆盖一个教室或一个机房； 城域网：覆盖范围较大，可以覆盖一个城市； 广域网：覆盖范围最大，可以覆盖全国，甚至全球，万维网是广域网的代表； IP地址 概念：用于唯一标识网络中每台计算机； 查看IP地址：ipconfig； IP地址的表示形式：点分十进制 xx.xx.xx.xx； 每一个十进制数的范围：0~255； IP地址的组成 = 网络地址 + 主机地址，比如：192.168.16.69； IPV6（16字节，16进制表示）是互联网工程任务组设计的用于替代IPV4的下一代IP协议，其地址数量号称可以为全世界的每一粒沙子编上一个地址； 由于IPV4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPV6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍。 IPV4地址分类 ==特殊的 127.0.0.1 表示本机地址== 域名和端口 域名 例如，www.baidu.com 好处：为了方便记忆，解决记忆IP地址的困难； 概念：将IP地址映射成域名； 端口号 概念：用于标识计算机上某个特定的网络程序； 表示形式：以整数形式，范围：0 ~ 65535； 0 ~ 1024已经被占用，比如 ssh 22， ftp 21， smtp 25， http 80； 常见的网络程序端口号 tomcat：8080 mysql：3306 oracle：1521 sqlserver：1433 端口号是用来区分不同服务的 网络通信协议 协议(TCP/IP) TCP/IP（Transmission Control Protocol/Internet Protocol的简写），中文译名为传输控制协议。因特网互联协议，又叫网络通讯协议，这个协议是Internet最基本的协议、Internet国际互联网络的基础，简单地说，就是由网络层的IP协议和传输层的TCP协议组成的。 在网络编程中数据的组织形式就是协议 弹幕摘要：协议的作用就是实现了对等实体之间的通信，同时也为上一层的协议提供服务，并享受下一层协议提供的服务。 网络通信协议 OSI模型（理论） TCP/IP模型 TCP/IP模型各层对应协议 应用层 应用层 HTTP、ftp、telnet、DNS…… 表示层 应用层 HTTP、ftp、telnet、DNS…… 会话层 应用层 HTTP、ftp、telnet、DNS…… 传输层 传输层（TCP） TCP、UDP…… 网络层 网络层（IP） IP、ICMP、ARP…… 数据链路层 物理+数据链路层 Link 物理层 物理+数据链路层 Link TCP 和 UDP TCP协议： 使用TCP协议前，须先建立TCP连接，形成传输数据通道； 传输前，采用”三次握手“方式，确认是可靠的； TCP协议进行通信的两个应用进程：客户端、服务端； 在连接中可以进行大数据量的传输； 传输完毕，需释放已建立的连接，效率低； UDP协议: 将数据、源、目的封装成数据包，不需要建立连接； 每个数据包的大小限制在64K内； 因无需连接，故而是不可靠的； 发送数据结束时无需释放资源（因为不是面向连接的），速度快； 弹幕摘要： A：你能听到吗？ B:我能听到，你知道我能听到吗？ A:我知道你听到我说话了，我确信咱俩都能听到了。","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Java IO流 flush()的作用和缓冲流","slug":"Java-IO流-flush-的作用和缓冲流","date":"2023-05-17T14:50:51.000Z","updated":"2023-05-17T14:56:33.705Z","comments":true,"path":"9959b2c8.html","link":"","permalink":"http://example.com/9959b2c8.html","excerpt":"","text":"Java 缓冲流和flush()的作用哪些流是缓冲流，哪些流带有缓冲区？根据Java官方文档关于Buffered Streams的介绍，缓冲流有四种： BufferedInputStream：包装字节输入流 BufferedOutputStream：包装字节输出流 BufferedReader：包装字符输入流 BufferedWriter：包装字符输出流这些流又被称为包装流/处理流，用于包装非缓冲的流 There are four buffered stream classes used to wrap unbuffered streams: BufferedInputStream and BufferedOutputStream create buffered byte streams, while BufferedReader and BufferedWriter create buffered character streams.——JAVA Documentation：Basic I/O 所以被包装流包装过的流都是使用缓冲区的；缓冲流使用缓冲区；字节流默认不使用缓冲区；字符流使用缓冲区。 flush()方法的作用flush()：冲洗缓冲区，强制将缓冲区中的数据全部写入目标位置，清空缓冲区，不关闭流对象； 为什么用flush()：在使用Bufferd Streams输出流对象时，我们需要对缓冲区进行冲洗，因为我们读取数据时，数据会先被读取在缓冲区中，为了确保输出流中的数据被全部写入，要flush缓冲区，否则数据会停留在缓冲区，不会输出，导致数据损失； flush() :To flush output stream, use void flush() method of DataOutputStream class. This method internally calls flush() method of underlying OutputStream class which forces any buffered output bytes to be written in the stream.源自：https://stackoverflow.com/a/9272658/21906030 Flushing Buffered StreamsIt often makes sense to write out a buffer at critical points, without waiting for it to fill. This is known as flushing the buffer..Some buffered output classes support autoflush, specified by an optional constructor argument. When autoflush is enabled, certain key events cause the buffer to be flushed. For example, an autoflush PrintWriter object flushes the buffer on every invocation of println or format. See Formatting for more on these methods..To flush a stream manually, invoke its flush method. The flush method is valid on any output stream, but has no effect unless the stream is buffered——JAVA Documentation：Basic I/O","categories":[{"name":"java学习问题","slug":"java学习问题","permalink":"http://example.com/categories/java%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"编程问题","slug":"编程问题","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"mysql 锁","slug":"mysql-锁","date":"2023-05-09T13:39:09.000Z","updated":"2023-05-17T14:53:04.494Z","comments":true,"path":"3095cec1.html","link":"","permalink":"http://example.com/3095cec1.html","excerpt":"","text":"锁概述 介绍 锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。 分类 MySQL中的锁，按照锁的粒度分，分为以下三类： 全局锁：锁定数据库中的所有表。 表级锁：每次操作锁住整张表。 行级锁：每次操作锁住对应的行数据。 全局锁 介绍 全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，以及更新操作的事务提交语句都将被阻塞。 其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。 演示 语法 加锁：flush tables with read lock; 备份：mysqldump -u用户名 -p密码 数据库名称 &gt; 备份文件的路径，==注意mysqldump是MySQL提供的一个工具，不是SQL语句，所以不要在MySQL的命令行运行，直接在系统的命令行运行。== 释放锁：unlock tables; 特点 数据库中加全局锁，是一个比较重的操作，存在以下问题： 如果在主库上备份 ，那么在备份期间都不能执行更新，业务基本上就得停摆。 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制文件（binlog），会导致主从延迟。 在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份。 mysqldump --single-transaction -uxxx -pxxx 数据库名 &gt; 备份文件路径 表级锁 介绍 表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。 对于表级锁，主要分为以下三类： 表锁 元数据锁（meta data lock，MDL） 意向锁 表锁 对于表锁，分为两类： 表共享读锁（read lock） 表独占写锁（write lock） 语法： 加锁：lock tables 表名... read/write 释放锁：unlock tables / 客户端断开连接 ==读锁不会阻塞其他客户端的读，但是会阻塞写。写锁即会阻塞其他客户端的读，又会阻塞其他客户端的写。== 元数据锁（meta data lock，MDL） MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性（这里元数据可以理解为表结构），在表上有活动事务的时候，不可以对元数据进行写入操作。==为了避免DML与DDL冲突，保证读写的正确性。== 在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）。 对应SQL 元数据锁类型 说明 lock tables xxx read/write SHARED_READ_ONLY / SHARED_NO_READ_WRITE select、select...lock in share mode SHARED_READ 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 insert、update、delete、select ... for update SHARED_WRITE 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 alter table ... EXCLUSIVE 与其他的MDL都互斥 查看元数据锁： select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks; 意向锁 为了避免DML在执行时，加的行锁与表锁的冲突就，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。 意向共享锁（IS）：由语句select … lock in share mode 添加。与表锁共享锁（read）兼容，与表锁排他锁（write）互斥。 意向排他锁（IX）：由insert、update、delete、select … for update 添加。与表锁共享锁（read）及排他锁（write）都互斥。==意向锁之间不会互斥。== 可以通过以下SQL语句，查看意向锁及行锁的加锁情况： select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks; 弹幕笔记摘要： 明显写锁和谁都冲突，读锁和任何读锁都兼容，很好理解因为都只读； 总的来说，意向锁并不是真正意义上的锁，只是一个记载锁的数据结构，可以这么理解，不要被它的名字骗了； 要说意向锁是锁的话，那么它算是表级锁； 锁是一种资源，是要被争抢的，被事务获取； 产生意向锁时也会产生元数据锁； 原来懵的不止我一个(-_-)； 意向锁解决的是行锁和表锁的冲突问题； 行级锁 介绍 行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。 InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类： 行锁（Record Lock）：锁定单个记录的锁，防止其他事务对此进行update和delete。在RC、RR隔离级别下都支持。 间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。 临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。 行锁 InnoDB实现了以下两种类型的行锁： 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁； 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁； SQL 行锁类型 说明 INSERT … 排他锁 自动加锁 UPDATE … 排他锁 自动加锁 DELETE … 排他锁 自动加锁 SELECT(正常) 不加任何锁 SELECT … LOCK IN SHARE MODE 共享锁 需要手动在SELECT之后加LOCK IN SHARE MODE SELECT … FOR UPDATE 排他锁 需要手动在SELECT之后加 FOR UPDATE 默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。 InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁。 可以通过以下SQL，查看意向锁及行锁的加锁情况： select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks; 弹幕摘要：记住这里，select一定要自己主动去加锁，如果不主动加锁是可以发生幻读的； 间隙锁/临键锁 默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。 索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。 索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。 索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止。 ==注意 ：间隙锁的唯一目的就是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一个间隙上采用间隙锁。==","categories":[{"name":"mysql学习","slug":"mysql学习","permalink":"http://example.com/categories/mysql%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"mysql-触发器","slug":"mysql-触发器","date":"2023-05-09T13:37:31.000Z","updated":"2023-05-13T09:43:11.302Z","comments":true,"path":"d71f2100.html","link":"","permalink":"http://example.com/d71f2100.html","excerpt":"","text":"触发器介绍触发器是与表有关的数据库对象，指在insert/update/delete之前或之后，触发并执行触发器中定义SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。 使用别 名OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD INSERT型触发器 NEW 表示将要或者已经新增的数据类型 UPDATE型触发器 OLD 表示修改之前的数据，NEW 表示将要修改或者已经修改后的数据 DELETE型触发器 OLD 表示将要或者已经删除的数据 语法 创建 123456CREATE TRIGGER trigger_nameBEFORE/AFTER INSERT/UPDATE/DELETEON tbl_name FOR EACH ROW -- 行级触发器BEGIN trigger_stmt;END; 查看 1SHOW TRIGGERS; 删除 1DROP TRIGGER [schema_name.]trigger_name; -- 如果没有指定schema_name，默认为当前数据库。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263-- 触发器-- 准备工作：日志表 user_logsCREATE TABLE user_logs( id INT(11) NOT NULL auto_increment, operation VARCHAR(20) NOT NULL COMMENT &#x27;操作类型，insert/update/delete&#x27;, operate_time datetime NOT NULL COMMENT &#x27;操作时间&#x27;, operate_empno INT(11) NOT NULL COMMENT &#x27;操作的empno&#x27;, operate_params VARCHAR(1000) COMMENT &#x27;操作参数&#x27;, PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8;-- 插入数据触发器(insert)CREATE TRIGGER emp_insert_trigger AFTER INSERT ON emp FOR EACH ROWBEGIN INSERT INTO user_logs VALUES(null, &#x27;insert&#x27;, NOW(), new.empno, CONCAT(&#x27;输入的内容：&#x27;,new.empno,new.ename, new.job, new.mgr,new.hiredate,new.sal,new.comm,new.deptno));END; -- 查看 SHOW TRIGGERS;-- 删除DROP TRIGGER emp_insert_trigger;INSERT INTO emp VALUES(7800, &#x27;TIM&#x27;, &#x27;SALESMAN&#x27;,7902, &#x27;1980-12-15 00:00:00&#x27;, 900, 1000, 20);SELECT * FROM user_logs;-- 修改数据触发器(update)CREATE TRIGGER emp_update_trigger AFTER UPDATE ON emp FOR EACH ROWBEGIN INSERT INTO user_logs VALUES(null, &#x27;update&#x27;, NOW(), new.empno, CONCAT(&#x27;更新之前的数据：&#x27;,&#x27;empno=&#x27;,old.empno,&#x27;ename=&#x27;,old.ename,&#x27;job=&#x27;, old.job, &#x27;mgr=&#x27;,old.mgr,&#x27;hiredate=&#x27;,old.hiredate,&#x27;sal=&#x27;,old.sal,&#x27;comm=&#x27;,old.comm,&#x27;deptno=&#x27;,old.deptno,&#x27;| 更新之后的数据：&#x27;,&#x27;empno=&#x27;,new.empno,&#x27;ename=&#x27;,new.ename,&#x27;job=&#x27;, new.job, &#x27;mgr=&#x27;,new.mgr,&#x27;hiredate=&#x27;,new.hiredate,&#x27;sal=&#x27;,new.sal,&#x27;comm=&#x27;,new.comm,&#x27;deptno=&#x27;,new.deptno));END;SHOW TRIGGERS;UPDATE emp SET sal = 1900 WHERE empno = 7800;UPDATE emp SET sal = 1900 WHERE empno &lt; 7800; -- empno &lt; 7800 的记录有几条，就执行几次触发器SELECT * FROM user_logs;-- 删除数据的触发器（delete）CREATE TRIGGER emp_delete_trigger AFTER DELETE ON emp FOR EACH ROWBEGIN INSERT INTO user_logs VALUES(null, &#x27;delete&#x27;, NOW(), old.empno, CONCAT(&#x27;删除之前的数据：&#x27;,&#x27;empno=&#x27;,old.empno,&#x27;ename=&#x27;,old.ename,&#x27;job=&#x27;, old.job, &#x27;mgr=&#x27;,old.mgr,&#x27;hiredate=&#x27;,old.hiredate,&#x27;sal=&#x27;,old.sal,&#x27;comm=&#x27;,old.comm,&#x27;deptno=&#x27;,old.deptno));END;SHOW TRIGGERS;DELETE FROM emp WHERE empno = 7800;SELECT * FROM user_logs;","categories":[{"name":"mysql学习","slug":"mysql学习","permalink":"http://example.com/categories/mysql%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"p11 Properties","slug":"p11-Properties","date":"2023-05-08T13:37:21.000Z","updated":"2023-05-13T09:43:11.308Z","comments":true,"path":"c33f51f5.html","link":"","permalink":"http://example.com/c33f51f5.html","excerpt":"","text":"# Properties类 基本介绍 专门用于读写配置文件的集合类 配置文件的格式： 键=值 键=值 注意：键值对不需要有空格，值不需要用引号一起来。默认类型是String。 Properties的常见方法 load：加载配置文件的键值对 到Properties对象； list：将数据显示到指定设备/流对象； getProperty(key)：根据键获取值； setProperty(key, value)：设置键值对到Properties对象； store：将Properties中的键值对存储到配置文件，在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码； 读文件 示例文件：mysql.properties 123ip=192.168.100.100user=rootpwd=12345 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.util.Properties;/** * @author: 86199 * @date: 2023/5/8 20:06 * @description: */public class Properties02 &#123; public static void main(String[] args) throws IOException &#123; //使用Properties类 来读取mysql.properties 文件 //1. 创建Properties对象 Properties properties = new Properties(); //2. 加载指定配置文件 properties.load(new FileReader(&quot;src\\\\mysql.properties&quot;)); //3. 把 k-v 显示到控制台 properties.list(System.out); //4. 根据key获取对应的值 String user = properties.getProperty(&quot;user&quot;); String pwd = properties.getProperty(&quot;pwd&quot;); System.out.println(&quot;用户名 = &quot; + user); System.out.println(&quot;密码 = &quot; + pwd); &#125;&#125;/*运行结果：-- listing properties --user=rootpwd=12345ip=192.168.100.100root12345*/ 修改文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.io.FileOutputStream;import java.io.FileWriter;import java.io.IOException;import java.util.Properties;/** * @author: 86199 * @date: 2023/5/8 20:52 * @description: */public class Properties03 &#123; public static void main(String[] args) throws IOException &#123; //load加载的时候加载到properties对象，是继承了hashtable的， // 所以相同key的就替换value了 //使用Properties类 来创建 配置文件，修改配置文件内容 Properties properties = new Properties(); //创建 //1. 如果该文件没有这个key，就是创建 //2. 如果该文件有这个key，就是修改 /* Properties 父类是 Hashtable，底层就是Hashtable 核心方法 public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value;//如果 key 存在，就替换 return old; &#125; &#125; addEntry(hash, key, value, index);//如果是新k，就addEntry return null; &#125; */ properties.setProperty(&quot;charset&quot;, &quot;utf8&quot;); properties.setProperty(&quot;user&quot;,&quot;汤姆&quot;);//注意中文保存时，是保存中文的 unicode码 properties.setProperty(&quot;pwd&quot;,&quot;888888&quot;); //将k-v 存储到文件中即可 properties.store(new FileOutputStream(&quot;src\\\\mysql2.properties&quot;), null); System.out.println(&quot;保存配置文件成功~~&quot;); &#125;&#125; mysql2.properties文件内容： 12345#Mon May 08 21:16:41 CST 2023user=\\u6C64\\u59C6pwd=888888charset=utf8","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"mysql-存储函数","slug":"mysql-存储函数","date":"2023-05-08T07:35:53.000Z","updated":"2023-05-13T09:43:11.298Z","comments":true,"path":"803d30ed.html","link":"","permalink":"http://example.com/803d30ed.html","excerpt":"","text":"存储函数==存储函数==是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下： 123456CREATE FUNCTION 存储函数名称([参数列表])RETURNS type [characteristic ...]BEGIN -- SQL语句 RETURN ...;END; characteristic说明： DETERMINISTIC：相同的输入参数总是产生相同的结果； NO SQL：不包含SQL语句； READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。 代码演示： 123456789101112131415161718-- 存储函数-- 从1到n的累加CREATE FUNCTION fun1(n INT)RETURNS INT DETERMINISTICBEGIN DECLARE total INT DEFAULT 0; WHILE n &gt; 0 DO SET total := total + n; SET n := n - 1; END WHILE; RETURN total;END;SELECT fun1(10);","categories":[{"name":"mysql学习","slug":"mysql学习","permalink":"http://example.com/categories/mysql%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"p10 打印流","slug":"p10-打印流","date":"2023-05-07T14:19:46.000Z","updated":"2023-05-13T09:43:11.307Z","comments":true,"path":"3aacf741.html","link":"","permalink":"http://example.com/3aacf741.html","excerpt":"","text":"打印流PrintStream 和 PrintWriter 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.IOException;import java.io.PrintStream;/** * @author: 86199 * @date: 2023/5/7 21:17 * @description: 演示字节打印流/输出流 PrintStream */public class PrintStream_ &#123; public static void main(String[] args) throws IOException &#123; //System.out 在 Java 中也是一个 final 对象引用， // 但它的初始化是在 Java 虚拟机启动时完成的，被初始化为一个指向标准输出流的对象。 //指向的地址不能修改，这个指向的对象本身可以被修改 PrintStream out = System.out; //在默认情况下，PrintStream 输出数据的位置是 标准输出 即显示器 out.print(&quot;Hello World!&quot;); //因为print()的底层本身就是write()，所以我们可以直接调用write()进行打印/输出 /* 源码 public void print(String s) &#123; if (s == null) &#123; s = &quot;null&quot;; &#125; write(s); &#125; */ out.write(&quot;Hello World!&quot;.getBytes()); out.close(); //我们可以修改打印流输出的位置/设备 System.setOut(new PrintStream(&quot;e:\\\\f1.txt&quot;)); System.out.println(&quot;Hello World!&quot;);//会输出到文件中 /* public static void setOut(PrintStream out) &#123; checkIO(); setOut0(out);//native方法，修改了out &#125; */ &#125;&#125; 1234567891011121314151617181920import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;/** * @author: 86199 * @date: 2023/5/7 21:51 * @description: 演示 PrintWriter 使用方式 */public class PrintWriter_ &#123; public static void main(String[] args) throws IOException &#123;// PrintWriter printWriter = new PrintWriter(System.out); PrintWriter printWriter = new PrintWriter(new FileWriter(&quot;e:\\\\f2.txt&quot;)); printWriter.print(&quot;三国演义 very good!&quot;); //不关闭流数据就不会输出 printWriter.close(); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"p9 转换流-InputStreamReader 和 OutputStreamWriter","slug":"p9-转换流-InputStreamReader-和-OutputStreamWriter","date":"2023-05-07T14:18:02.000Z","updated":"2023-05-13T09:43:11.321Z","comments":true,"path":"941525aa.html","link":"","permalink":"http://example.com/941525aa.html","excerpt":"","text":"转换流-InputStreamReader 和 OutputStreamWriter 介绍 InputStreamReader：Reader的子类，可以将InputStream（字节流）包装成Reader（字符流）； OutputStreamWriter：Writer的子类，实现将OutputStream（字节流）包装成Writer（字符流）； 当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流； 可以在使用时指定编码格式（比如 utf-8，gbk，gb2312，ISO8859-1等），解决乱码问题； InputStreamReader 代码演示： 123456789101112131415161718192021import java.io.*;/** * @author: 86199 * @date: 2023/5/7 17:18 * @description: 演示使用 InputStreamReader 转换流解决中文乱码问题 * 将字节流 FileInputStream 转换成字符流 InputStreamReader，指定编码 gbk/utf-8 */public class InputStreamReader_ &#123; public static void main(String[] args) throws IOException &#123; String filePath = &quot;e:\\\\a.txt&quot;; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(filePath), &quot;gbk&quot;)); //读取 String s = bufferedReader.readLine(); System.out.println(&quot;读取内容 = &quot; + s); //关闭流 bufferedReader.close(); &#125;&#125; OutputStreamWriter 代码演示： 123456789101112131415161718192021222324package com.hsp.transformation;import java.io.*;/** * @author: 86199 * @date: 2023/5/7 17:31 * @description: 演示 OutputStreamWriter 使用，把FileOutputStream 字节流，转成OutputStreamWriter * 指定处理的编码 gbk/utf-8/utf8 */public class OutputStreamWriter_ &#123; public static void main(String[] args) throws IOException &#123; String filePath = &quot;e:\\\\test.txt&quot;; String charSet = &quot;utf8&quot;; OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(filePath), charSet); outputStreamWriter.write(&quot;只因你太美&quot;); outputStreamWriter.close(); System.out.println(&quot;文件按照&quot; + charSet + &quot;保存成功&quot;); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"p8 标准输入输出流","slug":"p8-标准输入输出流","date":"2023-05-07T14:17:03.000Z","updated":"2023-05-13T09:43:11.319Z","comments":true,"path":"a4b4e77f.html","link":"","permalink":"http://example.com/a4b4e77f.html","excerpt":"","text":"标准输入输出流 流 编译类型 运行类型 默认设备 System.in 标准输入 InputStream BufferedInputStream 键盘 System.in 标准输出 PrintStream PrintStream 显示器 代码演示： 123456789101112131415161718192021222324252627282930import java.util.Scanner;/** * @author: 86199 * @date: 2023/5/7 16:11 * @description: */public class InputAndOutput &#123; public static void main(String[] args) &#123; //System类 的public final static InputStream in = null; //System.in 编译类型 InputStream //System.in 运行类型 BufferedInputStream //表示标准输入 键盘 System.out.println(System.in.getClass()); //System.out： public final static PrintStream out = null; //System.out 编译类型 PrintStream //System.out 运行类型 PrintStream //表示的时标准输出 显示器 System.out.println(System.out.getClass()); System.out.println(&quot;Hello World&quot;); Scanner scanner = new Scanner(System.in); System.out.println(&quot;输入内容：&quot;); String next = scanner.next(); System.out.println(&quot;next = &quot; + next); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"p7 对象流-ObjectInputStream 和 ObjectOutputStream","slug":"p7-对象流-ObjectInputStream-和-ObjectOutputStream","date":"2023-05-07T14:14:08.000Z","updated":"2023-05-20T08:59:51.949Z","comments":true,"path":"4a64dcab.html","link":"","permalink":"http://example.com/4a64dcab.html","excerpt":"","text":"对象流ObjectInputStream和ObjectOutputStream引言 看一个需求 将int num=100这个 int 数据保存到文件中，注意不是 100 数字，而是 int 100，并且，能够从文件中直接恢复 int 100； 将Dog dog = new Dog(“小黄”，3)这个dog对象保存到文件中，并且能够从文件恢复； 上面的要求，就是能够将 基本数据类型 或者 对象 进行 序列化 和 反序列化 操作； 序列化和反序列化 序列化就是在保存数据时，保存数据的值和数据类型； 反序列化就是在恢复数据时，恢复数据的值和数据类型； 需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一： Serializable：这是一个标记接口，没有方法 Externalizable：该接口有方法需要实现，因此我们一般实现上面的Serializable 基本介绍 功能：提供了对基本类型或对象类型的序列化和反序列化的方法； ObjectOutputStream 提供 序列化功能； ObjectInputStream 提供 反序列化功能； ObjectOutputStream 代码演示： 123456789101112131415161718192021222324252627282930import java.io.*;/** * @author: 86199 * @date: 2023/5/5 21:51 * @description: 演示ObjectOutputStream的使用，完成数据的序列化 */public class ObjectOutputStream_ &#123; public static void main(String[] args) throws IOException &#123; //序列化后，保存的文件格式，不是纯文本，而是按照序列化自己规定的格式来保存 String filePath = &quot;e:\\\\data.dat&quot;; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath)); //序列化数据到 e:\\data.dat oos.writeInt(100);//int -&gt; Integer（实现了 Serializable） oos.writeBoolean(true);//boolean -&gt; Boolean（实现了 Serializable） oos.writeChar(&#x27;a&#x27;);//char -&gt; Character（实现了 Serializable） oos.writeDouble(9.5);//double -&gt; Double（实现了 Serializable） oos.writeUTF(&quot;红楼梦&quot;);//String //保存一个dog对象 oos.writeObject(new Dog(&quot;旺财&quot;,10)); //关闭流 oos.close(); System.out.println(&quot;数据保存完毕（序列化形式）&quot;); &#125;&#125; Dog类代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.Serializable;/** * @author: 86199 * @date: 2023/5/5 23:09 * @description: *///如果需要序列化某个对象，实现 Serializablepublic class Dog implements Serializable &#123; private String name; private int age; //序列化对象时，默认将里面所有的属性都进行序列化，但除了static或transient修饰的成员 private static String nation; private transient String color; //序列化对象化时，要求里里面的属性的类型也必须实现序列化接口 private Master master = new Master(); //serialVersionUID 序列化的版本号，可以提高兼容性 //这样对该类进行修改后，进行序列化或者反序列化时就不会认为该类 //是全新的类，只是进行了版本更新 //对象的序列化反序列化是根据序列化版本id进行的，没有显式得写出来会默认根据类的属性和方法分配一个。导致对象序列化入库之后，若类被修改，反序列化将会报错。所以显式加上序列化版本id，避免反序列化报错 private static final long serialVersionUID = 1L; public Dog(String name, int age, String nation, String color) &#123; this.name = name; this.age = age; this.color = color; this.nation = nation; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, color = &#x27;&quot; + color + &#x27;\\&#x27;&#x27; + &quot;, nation = &#x27;&quot; + nation + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27; + &quot; &quot; + master; &#125;&#125; ObjectInputStream 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;import com.hsp.outputstream_.Dog;/** * @author: 86199 * @date: 2023/5/5 22:28 * @description: 演示ObjectInputStream的使用，完成数据的反序列化 */public class ObjectInputStream_ &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //指定反序列化的文件 String filePath = &quot;e:\\\\data.dat&quot;; //反序列化时，要保证和序列化时的信息是一致的，若被序列化的数据的类信息有改动，此时直接反序列化自然会出错，需要重新序列化数据(如果Dog加了serialVersionUID就不会报错) ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath)); //读取 //读取（反序列化）的顺序需要和保存数据（序列化）的顺序一致，否则会出现异常 System.out.println(ois.readInt()); System.out.println(ois.readBoolean()); System.out.println(ois.readChar()); System.out.println(ois.readDouble()); System.out.println(ois.readUTF()); Object dog = ois.readObject();//底层Object -&gt; Dog System.out.println(&quot;运行类型 = &quot; + dog.getClass()); System.out.println(&quot;dog信息 = &quot; + dog); //要想使用 我们这个反序列化来的Dog对象，还得使Dog可以在这被引用，然后向下转型 //1. 如果我们希望调用Dog的方法，需要向下转型 //2. 需要我们将Dog类的定义，放在可以引用的位置 Dog dog2 = (Dog)dog; System.out.println(dog2.getName()); //关闭流 ois.close(); &#125;&#125;/*运行结果100truea9.5红楼梦运行类型 = class com.hsp.outputstream_.Dogdog信息 = Dog&#123;name=&#x27;旺财&#x27;, age=10, color = &#x27;null&#x27;, nation = &#x27;null&#x27;&#125; com.hsp.outputstream_.Master@66a29884旺财*/","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"p6 BufferedInputStream 和 BufferedOutputStream","slug":"p6-BufferedInputStream-和-BufferedOutputStream","date":"2023-05-07T14:06:14.000Z","updated":"2023-05-13T09:43:11.316Z","comments":true,"path":"dd2d5e65.html","link":"","permalink":"http://example.com/dd2d5e65.html","excerpt":"","text":"BufferedInputStream 和 BufferedOutputStream BufferedInputStream BufferedInputStream是字节流，在创建BufferedInputStream时，会创建一个内部缓冲区数组。 构造方法摘要 Constructor and Description BufferedInputStream(InputStream in)创建一个 BufferedInputStream并保存其参数，输入流 in ，供以后使用。 BufferedInputStream(InputStream in, int size)创建 BufferedInputStream具有指定缓冲区大小，并保存其参数，输入流 in ，供以后使用。 方法摘要 Modifier and Type Method and Description int available()返回从该输入流中可以读取（或跳过）的字节数的估计值，而不会被下一次调用此输入流的方法阻塞。 void close()关闭此输入流并释放与流相关联的任何系统资源。 void mark(int readlimit)见的总承包 mark的方法 InputStream 。 boolean markSupported()测试这个输入流是否支持 mark和 reset方法。 int read()见 read法 InputStream的一般合同。 int read(byte[] b, int off, int len)从给定的偏移开始，将字节输入流中的字节读入指定的字节数组。 void reset()见 reset法 InputStream的一般合同。 long skip(long n)见 skip法 InputStream的一般合同。 BufferedOutputStream BufferedOutputStream是==字节流==，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统。 Constructor and Description BufferedOutputStream(OutputStream out)创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 BufferedOutputStream(OutputStream out, int size)创建一个新的缓冲输出流，以便以指定的缓冲区大小将数据写入指定的底层输出流。 Modifier and Type Method and Description void flush()刷新缓冲输出流。 void write(byte[] b, int off, int len)从指定的字节数组写入 len个字节，从偏移 off开始到缓冲的输出流。 void write(int b)将指定的字节写入缓冲的输出流。","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"p5 节点流 和 处理流","slug":"p5-节点流-和-处理流","date":"2023-05-04T14:44:08.000Z","updated":"2023-05-13T09:43:11.318Z","comments":true,"path":"769f414f.html","link":"","permalink":"http://example.com/769f414f.html","excerpt":"","text":"节点流 和 处理流 节点流和处理流一览图： ​ 【图片来源】http://t.csdn.cn/d52a1 基本介绍 节点流：节点流可以从一个特定的数据源==读写数据==，如FIleReader、FileWriter 处理流：处理流（也叫包装流）是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，也更加灵活，如BufferedReader、BufferedWriter。使用了修饰器设计模式。就是面向对象的封装思想，消除不同数据之间的差异性，仅对外暴露接口。 节点流 和 处理流 的区别和联系 节点流是底层流/低级流，直接跟数据源相接。 处理流（包装流）包装结点流，即可以消除不同节点的实现差异，也可以提供更方便的方法来完成输入输出。 处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * @author * @version 1.0 * 模拟修饰器设计模式 */public class Test_ &#123; public static void main(String[] args) &#123; BufferedReader_ bufferedReader_ = new BufferedReader_(new FileReader_()); bufferedReader_.readFiles(10); //希望通过BufferedReader_ 多次读取字符串 BufferedReader_ bufferedReader_1 = new BufferedReader_(new StringReader_()); bufferedReader_1.readStrings(5); &#125;&#125;abstract class Reader_ &#123; public void readFile_()&#123;&#125; public void readString_()&#123;&#125; //在Reader_抽象类，使用read方法统一管理// public abstract void read(); //后面在调用时就，利于对象动态绑定机制，绑定到对应的实现子类即可。&#125;// 模拟节点流class FileReader_ extends Reader_&#123; public void readFile_()&#123; System.out.println(&quot;对文件进行读取……&quot;); &#125;// public void read()&#123;// System.out.println(&quot;对文件进行读取……&quot;);// &#125;&#125;//模拟节点流class StringReader_ extends Reader_&#123; public void readString_()&#123; System.out.println(&quot;读取字符串……&quot;); &#125;// public void read()&#123;// System.out.println(&quot;读取字符串……&quot;);// &#125;&#125;//模拟处理流/包装流class BufferedReader_ extends Reader_&#123; //注意装饰器模式中，装饰类和被装饰类（约定俗成，而非必须）继承自同一个父类。 private Reader_ reader_;//属性是 Reader_ //接收Reader_子类对象 public BufferedReader_(Reader_ reader_) &#123; this.reader_ = reader_; &#125; public void readFile()&#123; reader_.readFile_(); &#125; //让方法更灵活，多次读取文件，或者加缓冲char[].... public void readFiles(int num)&#123; for (int i = 0; i &lt; num; i++) &#123; reader_.readFile_(); &#125; &#125; //扩展 readString，批量处理字符串数据 public void readStrings(int num)&#123; for (int i = 0; i &lt; num; i++) &#123; reader_.readString_(); &#125; &#125;&#125; 处理流的功能主要体现在以下两个方面： 性能的提高：主要以增加缓冲的方式来提高输入和输出的效率。 操作的便捷：处理流提供了一系列便捷的方法来一次输入输出大批量的数据就，使用更加灵活方便。 处理流 — BufferedReader和BufferedWriter BufferedReader 和 BufferedWriter属于字符流，是按照字符来读取数据的； 关闭处理流，只需关闭外层流即可，关闭外层流（包装流）时会自动关闭包装的节点流； BufferedReader 和 BufferedWriter 是安装字符操作，不要去操作二进制文件，可能造成文件损坏； BufferedReader 构造方法摘要 Constructor and Description BufferedReader(Reader in)创建使用默认大小的输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz)创建使用指定大小的输入缓冲区的缓冲字符输入流。 方法摘要 Modifier and Type Method and Description void close()关闭流并释放与之相关联的任何系统资源。 Stream&lt;String&gt; lines()返回一个 Stream ，其元素是从这个 BufferedReader读取的行。 void mark(int readAheadLimit)标记流中的当前位置。 boolean markSupported()告诉这个流是否支持mark（）操作。 int read()读一个字符 int read(char[] cbuf, int off, int len)将字符读入数组的一部分。 String readLine()读一行文字。 boolean ready()告诉这个流是否准备好被读取。 void reset()将流重置为最近的标记。 long skip(long n)跳过字符 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;/** * @author * @version 1.0 * 演示BufferedReader的使用 */public class BufferedReader_ &#123; public static void main(String[] args) throws IOException &#123; String filePath = &quot;e:\\\\a.java&quot;; //创建BufferedReader对象 BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath)); //读取 String line;//按行读取，效率高 //1. bufferedReader.readLine() 是按行读取文件 //2. 当返回null时，表示文件读取完毕 while((line = bufferedReader.readLine()) != null)&#123; System.out.println(line); &#125; //关闭流 //这里注意，只需关闭 BufferedReader(外层流)，因为底层会自动的去关闭节点流 FileReader /** * public void close() throws IOException &#123; * synchronized (lock) &#123; * if (in == null) * return; * try &#123; * in.close(); * &#125; finally &#123; * in = null;// in 就是我们传入的 new FileReader(filePath)，关闭了 * cb = null; * &#125; * &#125; * &#125; */ bufferedReader.close(); &#125;&#125; BufferedWriter 构造方法摘要 Constructor and Description BufferedWriter(Writer out)创建使用默认大小的输出缓冲区的缓冲字符输出流。 BufferedWriter(Writer out, int sz)创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区。 方法摘要 Modifier and Type Method and Description void close()关闭流，先刷新。 void flush()刷新流。 void newLine()写一行行分隔符。 void write(char[] cbuf, int off, int len)写入字符数组的一部分。 void write(int c)写一个字符 void write(String s, int off, int len)写一个字符串的一部分。 代码演示： 12345678910111213141516171819import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class BufferedWriter_ &#123; public static void main(String[] args) throws IOException &#123; String filePath = &quot;e:\\\\BufferedWriter_.java&quot;; BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePath, true)); bufferedWriter.write(&quot;hello, 你好&quot;); //插入一个和系统 相关的换行 bufferedWriter.newLine();// bufferedWriter.write(&quot;\\r\\n&quot;); bufferedWriter.write(&quot;hello, 你好&quot;); //关闭外层流即可，传入的节点流会自动关闭 bufferedWriter.close(); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"p4 FileReader 和 FileWriter","slug":"p4-FileReader-和-FileWriter","date":"2023-05-04T14:37:01.000Z","updated":"2023-05-13T09:43:11.315Z","comments":true,"path":"c1a7681b.html","link":"","permalink":"http://example.com/c1a7681b.html","excerpt":"","text":"FileReader 和 FileWriterFileReader 和 File Writer 介绍FileReader 和 FileWriter 是字符流，即按照字符来操作 io FileReader 相关方法 构造方法摘要 Constructor and Description FileReader(File file)创建一个新的 FileReader ，给出 File读取。 FileReader(String fileName)创建一个新的 FileReader ，给定要读取的文件的名称。 FileReader(FileDescriptor fd)创建一个新的 FileReader ，给定 FileDescriptor读取。 相关方法摘要 Modifier and Type Method and Description int read()每次读取单个字符，返回该字符，如过达到文件末尾返回-1 int read(char[])批量读取多个字符到数组中，返回读取到的字符数，如过达到文件末尾返回-1 相关API： new String(char[])：将char[]转换成String new String(char[], off, len)：将char[]的指定部分转换成String 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import org.junit.jupiter.api.Test;import java.io.FileReader;import java.io.IOException;/** * @author * @version 1.0 */public class FileReader_ &#123; public static void main(String[] args) &#123; &#125; /** * 单个字符读取 */ @Test public void fileReader01()&#123; String filePath = &quot;e:\\\\story.txt&quot;; //创建FileReader对象 FileReader fileReader = null; int data = 0; try &#123; fileReader = new FileReader(filePath); //循环读取 while((data = fileReader.read()) != -1)&#123; System.out.print((char)data); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(fileReader != null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 字符数组读取 */ @Test public void fileReader02()&#123; String filePath = &quot;e:\\\\story.txt&quot;; FileReader fileReader = null; int readLen = 0; char[] buf = new char[8]; try &#123; //创建FileReader对象 fileReader = new FileReader(filePath); //循环读取 while((readLen = fileReader.read(buf)) != -1)&#123; System.out.print((new String(buf, 0, readLen))); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(fileReader != null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; FileWriter 相关方法 构造方法摘要 Constructor and Description FileWriter(File file)给一个File对象构造一个FileWriter对象。 FileWriter(File file, boolean append)给一个File对象构造一个FileWriter对象。 FileWriter(String fileName)构造一个给定文件名的FileWriter对象。 FileWriter(String fileName, boolean append)构造一个FileWriter对象，给出一个带有布尔值的文件名，表示是否附加写入的数据。 FileWriter(FileDescriptor fd)构造与文件描述符关联的FileWriter对象。 相关方法摘要 Modifier and Type Method and Description void writer()写入单个字符 void writer(char[])写入指定数组 void writer(char[], int off, int len)写入指定数组的指定部分 void writer(String str)写入整个字符串 void writer(String str, int off, int len))写入字符串的指定部分 相关API：String类：toCharArray()：将String转换成char[] ==注意：FileWriter使用后，必须要关闭（close）或刷新（flush），否则写入不到指定的文件。==在Java中使用FileWriter进行文件写入时，数据首先被缓存在内存中。当缓冲区满或者close()或flush()方法被调用时，缓冲区中的数据才会被真正地写入到文件中。如果没有关闭流或者flush缓冲区，缓冲区中的数据就会一直保留在内存中，而不会被写入到文件中。如果程序突然崩溃或者关闭，这些缓冲的数据将会丢失，这可能会导致数据的不完整或者文件损坏。 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.io.FileWriter;import java.io.IOException;/** * @author * @version 1.0 */public class FileWriter_ &#123; public static void main(String[] args) &#123; String filePath = &quot;e:\\\\note.txt&quot;; FileWriter fileWriter = null; char[] chars = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; try &#123; //创建FileWriter对象 fileWriter = new FileWriter(filePath);//默认是覆盖写入 //这种构造方法在使用FileWriter时，如果文件不存在，则会自动创建一个新的文件， // 如果文件已经存在，则会直接打开该文件并清空原有内容，从文件的开头开始写入新的内容。 //1. writer(int)：写入单个字符 fileWriter.write(&#x27;H&#x27;); //2. writer(char[])：写入指定数组 fileWriter.write(chars); //3. writer(char[], off, len)：写入指定数组的指定部分 fileWriter.write(&quot;中国四大名著&quot;.toCharArray(), 0, 3); //4. writer(string)：写入整个字符串 fileWriter.write(&quot;猪八戒娶媳妇&quot;); //5.writer(string, off, len)：写入字符串的指定部分 fileWriter.write(&quot;三打白骨精&quot;,0,2); //在数据量大的情况下可以循环操作 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //对应FileWriter，一定要关闭流，或者flush才能真正的把数据写入文件中 //看源码就知道原因 /* 源码： private void writeBytes() throws IOException &#123; this.bb.flip(); int var1 = this.bb.limit(); int var2 = this.bb.position(); assert var2 &lt;= var1; int var3 = var2 &lt;= var1 ? var1 - var2 : 0; if (var3 &gt; 0) &#123; if (this.ch != null) &#123; assert this.ch.write(this.bb) == var3 : var3; &#125; else &#123; this.out.write(this.bb.array(), this.bb.arrayOffset() + var2, var3); &#125; &#125; this.bb.clear(); &#125; */ //在Java中使用FileWriter进行文件写入时，数据首先被缓存在内存中。当缓冲区满或者close()或flush()方法被调用时，缓冲区中的数据才会被真正地写入到文件中。 // //如果没有关闭流或者flush缓冲区，缓冲区中的数据就会一直保留在内存中， // 而不会被写入到文件中。如果程序突然崩溃或者关闭，这些缓冲的数据将会丢失， // 这可能会导致数据的不完整或者文件损坏。 try &#123; fileWriter.close(); //关闭文件流，等价于flush() + 关闭// fileWriter.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"p3 FileInputStream 和 FileOutputStream","slug":"p3-FileInputStream-和-FileOutputStream","date":"2023-05-04T14:33:32.000Z","updated":"2023-05-13T09:43:11.312Z","comments":true,"path":"53b48ec9.html","link":"","permalink":"http://example.com/53b48ec9.html","excerpt":"","text":"FileInputStream 和 FileOutputStream InputStream：字节输入流 InputStream抽象类是所有类输入流的超类 InputStream 常用的子类 FileInputStream： 文件输入流 BufferedInputStream：缓冲字节输入流 ObjectInputStream：对象字节输入流 FileInputStream 构造方法摘要 Constructor and Description FileInputStream(File file)通过打开与实际文件的连接创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(FileDescriptor fdObj)创建 FileInputStream通过使用文件描述符 fdObj ，其表示在文件系统中的现有连接到一个实际的文件。 FileInputStream(String name)通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 方法摘要 Modifier and Type Method and Description int available()返回从此输入流中可以读取（或跳过）的剩余字节数的估计值，而不会被下一次调用此输入流的方法阻塞。 void close()关闭此文件输入流并释放与流相关联的任何系统资源。 protected void finalize()确保当这个文件输入流的 close方法没有更多的引用时被调用。 FileChannel getChannel()返回与此文件输入流相关联的唯一的FileChannel对象。 FileDescriptor getFD()返回表示与此 FileInputStream正在使用的文件系统中实际文件的连接的 FileDescriptor对象。 int read()从该输入流读取一个字节的数据。 int read(byte[] b)从该输入流读取最多 b.length个字节的数据为字节数组。 int read(byte[] b, int off, int len)从该输入流读取最多 len字节的数据为字节数组。 long skip(long n)跳过并从输入流中丢弃 n字节的数据。 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import org.junit.jupiter.api.Test;import java.io.FileInputStream;import java.io.IOException;/** * @author * @version 1.0 */public class FileInputStream_ &#123; public static void main(String[] args) &#123; &#125; /** * 演示读取文件 * read(byte b)单个字节的读取，效率较低 * 使用 read(byte[] b) 来读取 */ @Test public void readFile01()&#123; String filePath = &quot;e:\\\\hello.txt&quot;; int readData = 0; FileInputStream fileInputStream = null; try &#123; //创建 FileInputStream 对象，用于读取文件 fileInputStream = new FileInputStream(filePath); //从该输入流读取一个字节的数据。如果没有输入可用，此方法将阻止 //如果返回-1.表示读取完毕 while((readData = fileInputStream.read()) != -1)&#123; System.out.print((char)readData);//转成char显示 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; fileInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Test public void readFile02()&#123; String filePath = &quot;e:\\\\hello.txt&quot;; byte[] buf = new byte[8];//一次读8个字节 int readLen = 0; FileInputStream fileInputStream = null; try &#123; //创建 FileInputStream 对象，用于读取文件 fileInputStream = new FileInputStream(filePath);// 读取的字节数最多等于b的长度。// 令k为实际读取的字节数; 这些字节将存储在元素b[0]至b[ k -1] ，使元素b[ k ]至b[b.length-1]不受影响。// 返回读取到缓冲区的总字节数，或者如果没有更多的数据，因为已经到达流的末尾，则是 -1 。 while((readLen = fileInputStream.read(buf)) != -1)&#123; System.out.print(new String(buf, 0, readLen));//显示 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; fileInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/*运行结果 hello world hello world*/ FileOutputStream 构造方法摘要 Constructor and Description FileOutputStream(File file)创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(File file, boolean append)创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(FileDescriptor fdObj)创建文件输出流以写入指定的文件描述符，表示与文件系统中实际文件的现有连接。 FileOutputStream(String name)创建文件输出流以指定的名称写入文件。 FileOutputStream(String name, boolean append)创建文件输出流以指定的名称写入文件。 方法摘要 Modifier and Type Method and Description void close()关闭此文件输出流并释放与此流相关联的任何系统资源。 protected void finalize()清理与文件的连接，并确保当没有更多的引用此流时，将调用此文件输出流的 close方法。 FileChannel getChannel()返回与此文件输出流相关联的唯一的FileChannel对象。 FileDescriptor getFD()返回与此流相关联的文件描述符。 void write(byte[] b)将 b.length个字节从指定的字节数组写入此文件输出流。 void write(byte[] b, int off, int len)将 len字节从位于偏移量 off的指定字节数组写入此文件输出流。 void write(int b)将指定的字节写入此文件输出流。 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.junit.jupiter.api.Test;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;/** * @author * @version 1.0 */public class FileOutputStream_ &#123; public static void main(String[] args) &#123; &#125; @Test public void writeFile()&#123; String filePath = &quot;e:\\\\a.txt&quot;; FileOutputStream fileOutputStream = null; try &#123; String str = &quot;Hello World!&quot;; //得到FileOutputStream对象 //1. new FileOutputStream(filePath) 创建方式，写入内容会默认覆盖原来的内容 //2. new FileOutputStream(filePath, append) 创建方式，append 为ture，写入内容会默认追加至原来的内容后，否则就覆盖 fileOutputStream = new FileOutputStream(filePath, true); //写入一个字节 fileOutputStream.write(&#x27;H&#x27;); //写入字符串，str.getBytes() 可以把 字符串 -》字符数组 fileOutputStream.write(str.getBytes()); /* write(byte[] b, int off, int len) 将 len 字节从位于偏移量 off的指定字节数组写入文件输出流 */// fileOutputStream.write(str.getBytes(), 0, str.length()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"p2 IO流原理及流的分类","slug":"p2-IO流原理及流的分类","date":"2023-05-04T14:27:49.000Z","updated":"2023-05-13T09:43:11.310Z","comments":true,"path":"7eef035f.html","link":"","permalink":"http://example.com/7eef035f.html","excerpt":"","text":"Java IO流原理 I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理数据传输。如读/写文件，网络通讯等。 Java程序中，对于数据的输入/输出操作以”流（stream）“的方式进行。 java.io包下提供了各种”流“类和接口，用以获取不同种类的数据，并通过方法输入或输出数据。 输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。 输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。 流的分类 按操作数据单位不同分为：字节流（8bit）二进制文件适合，字符流（按字符）文本文件适合 按数据流的流向不同分为：输入流，输出流 按流的角色的不同分为：节点流，处理流/包装流 （1）Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生出来的。 （2）由这四个类派生出来的子类名称都是以其父类名作为子类名的后缀。 【图片来源：http://t.csdn.cn/c80Qi】 文件和流的关系： 文件是计算机管理数据的基本单位，同时也是应用程序保存和读取数据的一个重要场所。 流是字节序列的抽象概念，例如文件、输入/输出设备、内部进程通信管道等。流提供一种向后备存储器写入字节和从后备存储器读取字节的方式。 文件是流的载体，容器。","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"p1 文件的基本使用","slug":"p1-文件的基本使用","date":"2023-05-04T14:12:02.000Z","updated":"2023-05-13T09:43:11.303Z","comments":true,"path":"d549c55e.html","link":"","permalink":"http://example.com/d549c55e.html","excerpt":"","text":"文件的基本使用文件 什么是文件 文件是保存数据的地方，比如word文档，txt文件，excel文件……都是文件。即可以保存一张图片，也可以保持视频，声音…… 文件流 文件在程序中是以流的形式来操作的 流：数据在数据源（文件）和程序（内存）之间经历的路径 输入流： 数据从数据源（文件）到程序（内存）的路径 输出流：数据从程序（内存）到数据源（文件）的路径 常用的文件操作创建文件对象相关构造器和方法 new File(String pathName) ：根据路径构建一个File对象，类似绝对路径 new File(File parent, String child)：根据父目录文件夹和子路径构建，类似根据相对路径 new File(String parent, String child)：根据父目录 和 子路径构建 createNewFile()： 创建新文件 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.junit.jupiter.api.Test;import java.io.File;import java.io.IOException;/** * @author * @version 1.0 * 演示创建文件 */public class FileCreate &#123; public static void main(String[] args) &#123; &#125; //方式1 new File(String pathName)，类似根据绝对路径创建？ @Test public void create01()&#123; String pathName = &quot;e:\\\\news1.txt&quot;; File file = new File(pathName);//创建文件对象，此时只是有一个对象在jvm内存中 try &#123; file.createNewFile();//创建文件，这里才对磁盘做出操作，创建出文件 System.out.println(&quot;文件创建成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //方式2 new File(File parent, String child)，类似根据相对路径创建？ //根据父目录文件夹和子路径构建 @Test public void create02()&#123; File parentFile = new File(&quot;e:\\\\&quot;); String fileName = &quot;news2.txt&quot;; File file = new File(parentFile, fileName);//创建文件对象 try &#123; file.createNewFile();//创建文件 System.out.println(&quot;文件创建成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //方式3 new File(String parent, String child)，根据父目录 + 子路径构建 @Test public void create03()&#123;// String parentPath = &quot;e:\\\\&quot;; String parentPath = &quot;e:/&quot;;//也可以这么写 String fileName = &quot;news3.txt&quot;; File file = new File(parentPath, fileName); try &#123; file.createNewFile(); System.out.println(&quot;文件创建成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取文件的相关信息的方法 getName()，getAbsolutePath()，getParent()，length()，exists()，isFile()，isDirectory() 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.junit.jupiter.api.Test;import java.io.File;import java.io.IOException;public class FileInformation &#123; public static void main(String[] args) &#123; &#125; //获取文件信息 @Test public void info()&#123; //创建文件对象 File file = new File(&quot;e:\\\\news1.txt&quot;);//File对象只是一个路径，可能是文件也可能是目录（文件夹）// try &#123;// file.createNewFile();// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125; //获取文件名字 System.out.println(&quot;文件名字 = &quot; + file.getName()); //文件绝对路径 System.out.println(&quot;文件绝对路径 = &quot; + file.getAbsolutePath()); //文件父目录 System.out.println(&quot;文件父目录 = &quot; + file.getParent()); //文件大小 System.out.println(&quot;文件大小 = &quot; + file.length()); //文件是否存在 System.out.println(&quot;文件是否存在 = &quot; + file.exists()); //该对象对应的是不是文件 System.out.println(&quot;是不是一个文件 = &quot; + file.isFile()); //该对象对应的是不是目录 System.out.println(&quot;是不是一个目录 = &quot; + file.isDirectory()); &#125;&#125;/*运行结果：文件名字 = news1.txt文件绝对路径 = e:\\news1.txt文件父目录 = e:\\文件大小 = 18文件是否存在 = true是不是一个文件 = true是不是一个目录 = false*/ 目录的操作和文件删除 mkdir()：创建一级目录 mkdirs()：创建多级目录 delete()：删除空目录或文件 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import org.junit.jupiter.api.Test;import java.io.File;public class Directory_ &#123; public static void main(String[] args) &#123; &#125; //判断 e:\\\\news1.txt 是否存在，存在就删除 @Test public void m1()&#123; String filePath = &quot;e:\\\\news1.txt&quot;; File file = new File(filePath); if(file.exists())&#123; if(file.delete())&#123; System.out.println(filePath + &quot; 删除成功&quot;); &#125;else &#123; System.out.println(filePath + &quot; 删除失败&quot;); &#125; &#125;else &#123; System.out.println(&quot;文件不存在……&quot;); &#125; &#125; //判断 D:\\\\demo02 是否存在，存在就删除 //目录也是文件 @Test public void m2()&#123; String filePath = &quot;D:\\\\demo02&quot;; File file = new File(filePath); if(file.exists())&#123; if(file.delete())&#123; System.out.println(filePath + &quot; 删除成功&quot;); &#125;else &#123; System.out.println(filePath + &quot; 删除失败&quot;); &#125; &#125;else &#123; System.out.println(&quot;该目录不存在……&quot;); &#125; &#125; //判断D:\\\\demo\\\\a\\\\b\\\\c 目录是否存在，如果存在就提示已经存在，否则就创建 @Test public void m3()&#123; String directoryPath = &quot;D:\\\\demo\\\\a\\\\b\\\\c&quot;; File file = new File(directoryPath); if(file.exists())&#123; System.out.println(directoryPath + &quot;存在...&quot;); &#125;else &#123; if (file.mkdirs())&#123;//创建一级目录用mkdir()，创建多级目录使用mkdirs() System.out.println(directoryPath + &quot;创建成功...&quot;); &#125;else&#123; System.out.println(directoryPath + &quot;创建失败...&quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"mysql-存储过程","slug":"mysql-存储过程","date":"2023-05-02T07:33:39.000Z","updated":"2023-05-31T12:55:45.633Z","comments":true,"path":"e845031c.html","link":"","permalink":"http://example.com/e845031c.html","excerpt":"","text":"存储过程介绍存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用，类似于函数或者说API，封装了系列操作，暴露接口给你进行操作。 特点 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 基本语法 创建 1234CREATE PROCEDURE 存储过程名称([参数列表])BEGIN -- SQL语句END; 调用 1CALL 名称([参数]); 查看 1234-- 查询指定数据库的存储过程及状态信息SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#x27;数据库名称&#x27;;-- 查询某个存储过程的定义SHOW CREATE PROCEDURE 存储过程名称; 删除 1DROP PROCEDURE [IF EXISTS] 存储过程名称; ==注意：在命令行中，执行创建存储过程的SQL语句时，需要通过关键字 delimiter 指定SQL语句的结束符。== 代码演示： 123456789101112131415161718192021222324252627-- 存储过程基本语法-- 创建CREATE PROCEDURE p1()BEGIN SELECT COUNT(*) FROM emp;END;-- 如果在命令行执行的话，上面语句会出错，因为遇到第一个分号就结束了，-- 所以需要用到 delimiter-- delimiter $$ --表示指定 $$ 为结束符（记得之后再使用delimiter改回来）-- CREATE PROCEDURE p1()-- BEGIN-- SELECT COUNT(*) FROM emp;-- END;$$-- 这样就可以解决-- 调用CALL p1();-- 查看SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#x27;hsp_db02&#x27;;SHOW CREATE PROCEDURE p1;-- 删除DROP PROCEDURE IF EXISTS p1; 变量 系统变量 ==系统变量==是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（==GLOBAL==）、会话变量（==SESSION==）。 查看系统变量 123456-- 查看所有系统变量SHOW [SESSION|GLOBAL] VARIABLES;-- 可以通过LIKE模糊匹配方式查找变量、SHOW [SESSION|GLOBAL] VARIABLES LIKE &#x27;......&#x27;;-- 查看指定变量的值SELECT @@[SESSION|GLOBAL] 系统变量名; 设置系统变量 12SET [SESSION|GLOBAL] 系统变量名 = 值;SET @@[SESSION|GLOBAL]系统变量名 = 值; 注意： 如果没有指定是session或global，则默认是session，会话变量。 mysql服务重新启动后，所设置的全局参数会失效，要想不失效，可以在/etc/my.cnf中配置 代码演示： 123456789101112131415-- 变量：系统变量-- 查看系统变量show variables; -- 所有系统变量show session variables; -- 会话变量show global variables; -- 全局变量show session variables like &#x27;auto%&#x27;;show global variables like &#x27;auto%&#x27;;select @@global.autocommit;select @@session.autocommit;-- 设置系统变量set session autocommit = 0; -- 设置为0，代表关闭了当前会话的事务的自动提交set global autocommit = 0; -- 当服务器重启后，这个参数又会初始化为默认值，想要不失效，需要在etc/my.cnf中配置 用户定义变量 ==用户定义变量== 是用户根据需要自己定义的变量，用户不用提前声明，在用的时候直接用 “@变量名”使用就可以。其作用域为当前连接（会话）。 赋值 12SET @var_name = expr[,@var_name = expr]...;SET @var_name := expr[,@var_name := expr]...; 12SELECT @var_name := expr[,@var_name := expr]...;SELECT 字段名 INTO @var_name FROM 表名; 使用 1SELECT @var_name; 注意：用户定义的变量是无需对其进行声明或初始化的，只不过获取到的值为NULL。 代码演示： 1234567891011121314-- 变量：用户变量-- 赋值SET @myname = &#x27;itcast&#x27;;SET @myage := 10; -- 推荐set @mygender := &#x27;男&#x27;, @myhobby := &#x27;java&#x27;;SELECT @mycolor := &#x27;red&#x27;;SELECT COUNT(*) into @mycount FROM demo;-- 使用SELECT @myname, @myage, @mygender, @myhobby;SELECT @mycolor, @mycount;SELECT @abc; -- NULL 局部变量 ==局部变量==是根据需要定义在局部生效的变量，访问之前，需要DECLARE声明。可以用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN … END块中。 声明 1DECLARE 变量名 变量类型[DEFAULT ...]; 变量类型就是数据库字段类型：INT、BiGINT、CHAR、VARCHAR、DATE、TIME等。 赋值 123SET 变量名 = 值;SET 变量名 := 值;SELECT 字段名 INTO 变量名 FROM 表名...; 代码演示： 123456789101112-- 变量：局部变量-- 声明 declare-- 赋值CREATE PROCEDURE p2()BEGIN DECLARE stu_count INT DEFAULT 0; set stu_count := 100; SELECT COUNT(*) into stu_count FROM demo; SELECT stu_count;END;CALL p2(); if判断语法： 1234567IF 条件1 THEN ......ELSEIF 条件2 THEN -- 可选 ......ELSE -- 可选 ......END IF; 代码演示： 1234567891011121314151617CREATE PROCEDURE p1()BEGIN DECLARE score INT DEFAULT 58; DECLARE `result` VARCHAR(10); IF score &gt;= 85 THEN SET `result` := &#x27;优秀&#x27;; ELSEIF score &gt;= 60 THEN SET `result` := &#x27;及格&#x27;; ELSE SET `result` := &#x27;不及格&#x27;; END IF; SELECT `result`;END;CALL p1(); 参数 类型 含义 备注 IN 因为该类参数作为输入，也就是需要调用时传入值 默认 OUT 因为该类参数作为输出，也就是该类参数可以作为作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数 用法： 1234CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型])BEGIN -- SQL语句END; 代码演示： 123456789101112131415161718192021222324CREATE PROCEDURE p2(IN score INT, OUT `result` VARCHAR(10))BEGIN IF score &gt;= 85 THEN SET `result` := &#x27;优秀&#x27;; ELSEIF score &gt;= 60 THEN SET `result` := &#x27;及格&#x27;; ELSE SET `result` := &#x27;不及格&#x27;; END IF;END;CALL p2(68, @result);SELECT @result;CREATE PROCEDURE p3(INOUT score INT)BEGIN set score := score / 2;END;SET @score := 120;CALL p3(@score);SELECT @score; case 语法一 12345CASE case_value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list]END CASE; 语法二 12345CASE WHEN search_condition1 THEN statement_list1 [WHEN search_condition2 THEN statement_list2] [ELSE statement_list]END CASE; 代码演示： 1234567891011121314151617181920CREATE PROCEDURE p4(in month int)BEGIN declare result varchar(10); case when month &gt;= 1 and month &lt;= 3 THEN set result := &#x27;第一季度&#x27;; when month &gt;= 4 and month &lt;= 6 THEN set result := &#x27;第二季度&#x27;; when month &gt;= 7 and month &lt;= 9 THEN set result := &#x27;第三季度&#x27;; when month &gt;= 10 and month &lt;= 12 THEN set result := &#x27;第四季度&#x27;; else SET result := &#x27;非法参数&#x27;; END case; SELECT concat(&#x27;您输入的月份为：&#x27;, month, &#x27; 所属的季度为：&#x27;, result);END;CALL p4(4); 循环 循环－while while循环是有条件的循环控制语句，满足条件后在执行循环体内的SQL语句，具体语法如下： 1234#先判定条件，如果条件为true，则执行逻辑，否则不执行逻辑WHILE 条件 DO -- SQL逻辑END WHILE; 代码演示： 123456789101112#计算1到n的累加值CREATE procedure p5(in n int)BEGIN DECLARE total int DEFAULT 0; WHILE n &gt; 0 do set total := total + n; set n := n - 1; END WHILE; SELECT total;END;call p5(10); 循环－repeat repeat是有条件的循环控制语句，直到满足条件的时候退出循环。具体语法如下： 12345#先执行一次逻辑，然后判定是否满足条件，如果满足则退出，不满足，继续进行下一次循环REPEAT -- SQL逻辑 -- UNTIL 条件END REPEAT; 代码演示： 12345678910111213#计算1到n的累加值CREATE procedure p6(in n int)BEGIN DECLARE total int DEFAULT 0; repeat set total := total + n; set n := n - 1; UNTIL n &lt;= 0 end REPEAT; SELECT total;END;call p6(10); 循环－loop LOOP实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。LOOP可以配合以下两个语句使用： LEAVE：配合循环使用，退出循环。 ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。123[begin_label:] LOOP -- SQL逻辑END LOOP [end_label]; 12LEAVE label; -- 退出指定标记的循环体ITERATE label; -- 直接进入下一次循环 代码演示：1234567891011121314151617#计算1到n的累加值CREATE procedure p7(in n int)BEGIN DECLARE total int DEFAULT 0; `sum`:LOOP if n &lt;= 0 THEN Leave `sum`; END if; set total := total + n; set n := n - 1; end LOOP sum; SELECT total;END;call p7(10); 12345678910111213141516171819202122#计算1到n中的偶数的累加值CREATE procedure p8(in n int)BEGIN DECLARE total int DEFAULT 0; `sum`:LOOP if n &lt;= 0 THEN Leave `sum`; END if; IF n % 2 = 1 THEN set n := n - 1; iterate `sum`; end if; set total := total + n; set n := n - 1; end LOOP sum; SELECT total;END;call p8(10); 游标游标（CURSOR）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下： 声明游标 DECLARE 游标名称 CURSOR FOR 查询语句; 打开游标 OPEN 游标名称; 获取游标记录 FETCH 游标名称 INTO 变量[,变量]; 关闭游标 CLOSE 游标名称 123456789101112131415161718192021222324252627CREATE procedure p1(in uage int)BEGIN DECLARE u_name varchar(32); DECLARE u_profession varchar(32); DECLARE u_cursor CURSOR for SELECT name, profession FROM `user` where age &lt;= uage; -- DECLARE exit handler for sqlstate &#x27;02000&#x27; CLOSE u_cursor; DECLARE exit handler for Not FOUND CLOSE u_cursor; DROP TABLE if exists user_pro; CREATE TABLE user_pro( id int PRIMARY key AUTO_INCREMENT, name varchar(32), profession varchar(32) ); OPEN u_cursor; WHILE true do FETCH u_cursor INTO u_name, u_profession; INSERT into user_pro VALUES(null, u_name, u_profession); end WHILE;end;CALL p1(25);SELECT * from user_pro; user表：| id | name | age | profession || —- | ——– | —- | ———- || 1 | 孙悟空 | 20 | java || 2 | 猪八戒 | 21 | php || 3 | 沙和尚 | 22 | C || 4 | 唐僧 | 19 | C++ || 5 | 观音 | 24 | C# || 6 | 佛祖 | 30 | js || 7 | 玉皇大帝 | 31 | ts || 8 | 西王母 | 29 | python || 9 | 哪吒 | 15 | go | user_pro表：| id | name | profession || —- | —— | ———- || 1 | 孙悟空 | java || 2 | 猪八戒 | php || 3 | 沙和尚 | C || 4 | 唐僧 | C++ || 5 | 观音 | C# || 6 | 哪吒 | go | 条件处理程序-handler==条件处理程序（Handler）==可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤，具体语法如下： 1DECLARE handler_action HANDLER FOR condition_value[,condition_value]... statement; handler_action： CONTINUE：继续执行当前程序 EXIT：终止执行当前程序 condition_value： SQLSTATE sqlstate_value：状态码，如02000； SQLWARNING：所有以01开头的SQLSTATE代码的简写； NOT FOUND：所有以02开头的SQLSTATE代码的简写； SQLEXCEPTION：所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE代码的简写","categories":[{"name":"mysql学习","slug":"mysql学习","permalink":"http://example.com/categories/mysql%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-05-01T13:10:31.346Z","updated":"2023-05-13T09:43:11.296Z","comments":true,"path":"4a17b156.html","link":"","permalink":"http://example.com/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"b站韩顺平java学习笔记","slug":"b站韩顺平java学习笔记","permalink":"http://example.com/categories/b%E7%AB%99%E9%9F%A9%E9%A1%BA%E5%B9%B3java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"B站Servlet教程","slug":"B站Servlet教程","permalink":"http://example.com/categories/B%E7%AB%99Servlet%E6%95%99%E7%A8%8B/"},{"name":"B站尚硅谷JavaWeb学习笔记","slug":"B站尚硅谷JavaWeb学习笔记","permalink":"http://example.com/categories/B%E7%AB%99%E5%B0%9A%E7%A1%85%E8%B0%B7JavaWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"java学习问题","slug":"java学习问题","permalink":"http://example.com/categories/java%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98/"},{"name":"mysql学习","slug":"mysql学习","permalink":"http://example.com/categories/mysql%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"编程问题","slug":"编程问题","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}